<template>
<div class="side-pane" :class="{ 'fold': fold }" :style="{ height }">
    <!-- 侧边内容 -->
    <div class="side-pane-left" :style="{ width: sideWidth}">
        <transition name="side-pane-left">
            <div class="side-pane-left-con" v-if="!fold">
                <div class="side-pane-left-header" v-if="$slots.leftHeader">
                    <slot name="leftHeader"></slot>
                </div>
                <el-input placeholder="请输入网站标题" v-model="input" clearable @clear="handleClear">
                    <el-button @click="handleSearch"  slot="prepend" icon="el-icon-search" style="color:white"></el-button>
                </el-input>
                <el-button @click="clusterLayout">团伙聚类</el-button>
                <el-button class="expand-button" @click="expandLeftSide">{{expandButtonText}}</el-button>
                <!-- <el-button @click="drawer = true" type="primary" style="margin-left: 16px;">
                    点我打开
                </el-button>
                <el-drawer
                    title="我是标题"
                    style="height:50%;margin-top:60px"
                    :visible.sync="drawer"
                    :direction="direction"
                    :before-close="handleClose">
                    <span>我来啦!</span>
                    
                </el-drawer> -->
                <div v-if="expandLeft"> 

                    伸长部分
                </div>
                <!-- 默认展示关键节点（Pagerank） -->
                <div v-else style="margin-top:20px">
                    <div style="height:530px;overflow:hidden;"> 
                        <el-scrollbar>
                            <div style="height:560px">
                                <div class="nodeBox" v-for="(item,index) in tableData.slice(0,10)" :key="index"> 
                                    <el-button @click="clickWebsiteButton(item)" round class="custom-button" type="primary" size="small" v-bind:style="{ backgroundColor: node.color,borderColor:node.color }">Domain</el-button>
                                    <span style="width:100px;" > 
                                        {{ item.properties.Website_title }}
                                    </span>
                                </div>
                            </div>
                        </el-scrollbar>
                    </div>
                    
                </div>

                <!-- 侧边主体内容区 -->
                <div class="side-pane-left-body">
                    <slot name="left"></slot>
                </div>
            </div>
        </transition>
        <el-button class="fold-btn" type="text" :icon="iconType" @click="changeFold"></el-button>
    </div>

    <!-- 主体内容 -->
    <div class="side-pane-main">
    <div class="side-pane-main-header" v-if="$slots.mainHeader">
        <slot name="mainHeader"></slot>
    </div>

    
    <!-- 主体内容区 -->
    <div class="side-pane-main-body">
        <!-- <slot name="main">dddddd</slot> -->
        <!-- <gan1/> -->
        <div id="group-graph" class="group-graph"></div>
    </div>





    </div>
</div>
</template>
    
<script>
import gan1 from "../component/gan1.vue";
import insertCss from 'insert-css';
import G6 from '@antv/g6';
import screenfull from 'screenfull';
import { pageRank } from "@antv/algorithm";
import { isNumber, isArray } from '@antv/util';

export default {
    components:{
        gan1
    },
    props: {
        height: {
        type: String,
        default: '100%'
        },
    },
    computed: {
        marginLeft () {
            return this.fold ? 0 : this.sideWidth
        },

    },
    data () {
        return {
            sideWidth:"340px",
            fold: false,
            expandLeft:false, //是否扩展左侧栏
            iconType:"el-icon-arrow-left",
            expandButtonText:'展开',

            input:'',
            graph:'',
            graphData:'',
            tableData:'',
            node:{
                color:'#9661BC'
            },
            pathNodeIcon:{
                "Website":"#9661BC","Person":"#F6903D","Company":"#5F95FF","Ip":"#61DDAA","Redirect":"#F08BB4"
            },
        }
    },

    methods: {
        handleSearch(){
            const filteredData = this.tableData.filter(item => {
                return item.properties.Website_title.includes(this.input);
            })
            console.log(filteredData)
            this.tableData=filteredData;

            // this.axios({
            //     url:'api/graph/websites?wname='+this.input,
            //     method:'get'
            // }).then(res=>{
            //     this.tableData=res.data;
            //     console.log(this.tableData)
                //TODO：点击button则在图中高亮此节点
                //要不要pagerank突出较大的重要节点
                //可以，就在默认的列表里从高到低展示PageRank网站节点
            // })
        },
        handleClear(){
            this.tableData=this.graphData.nodes
        },
        getAllWebsites(){
            const limit = 300;
            var url = 'api/graph/websites?limit='+limit+'&wname=';
            var all='api/graph/websites?limit='+'&wname=';
            this.axios({
                url:all,
                method:'get'
            }).then(res=>{
                // this.$store.commit('setGraphData', res.data)
                this.graphData = res.data;
                this.tableData = res.data.nodes;
                this.processPageRank();
                // this.showAllGraph();
            })
        },
        processPageRank(){
            let result = pageRank(this.graphData);
            // console.log(result);
            //归一化
            let maxPR = -Infinity;
            let minPR = Infinity;
            for (let key in result) {
                    const PR = result[key];
                    maxPR = Math.max(maxPR, PR);
                    minPR = Math.min(minPR, PR);
            }
            let normalizedResult = {};
            for (let key in result) {
                const PR = result[key];
                const normalizedPR = (PR - minPR) / (maxPR - minPR);
                normalizedResult[key] = normalizedPR+0.5; //加上偏移0.5 否则有数为0
            }

            // 输出归一化后的结果
            // console.log("guiyi",normalizedResult)

            // this.graphData.nodes.forEach(node => {
            //     node.pageRank = result[node.id]*100;//直接用pagerank的值进行resize
            //     // node.pageRank = normalizedResult[node.id]; //归一化后resize
            // });
            this.showAllGraph();
            // console.log(this.graphData.nodes.sort((a, b) => b.pageRank - a.pageRank))
        },
        showAllGraph(){
            var data = this.graphData
            const containerId = "group-graph"
            const graphDiv = document.getElementById(containerId);
            const container = document.getElementById(containerId);
            const width = container.scrollWidth ||800;
            const height = container.scrollHeight ||640; //TODO:原本为450，这里修改画布的高度
            // 灰色区域
            const constrainBox = { x: 300, y: 20, width: 640, height: 640 };
            const canvasBackgroundColor = '#363B40';
            const darkBackColor = '#2B384E'; //TODO:这里修改节点的背景颜色 原本rgb(43, 47, 51)
            container.style.backgroundColor = canvasBackgroundColor; //TODO:背景颜色?
            const nodeSize =20;
            const linkDistance = 130; //边的长度
            const nodeStrength = -5; //节点斥力
            const realEdgeOpacity = 0.4; //
            const lineWidth = 1.3;
            const clusterNode = ["Website","Company","Person","Ip","Redirect"];
            const clusterEdge = ["BELONGS_TO","DOWNLOAD_FROM","HAS_IP","HAS_COMPANY","SIMILAR_TO"];
            const subjectColors = [
                '#9661BC', //purple
                '#7262FD',//purple
                '#78D3F8',
                '#F6903D',
                '#008685',
                '#F08BB4',
                '#5F95FF', // blue
                '#61DDAA', //green
                '#65789B', //grey
                '#F6BD16', //yellow
                // '#F08BB4',
                // '#F08BB4',
                // '#F08BB4',
            ];
            const backColor = '#fff';//
            const theme = 'default';
            const disableColor = '#777';
            const colorSets = G6.Util.getColorSetsBySubjectColors(
                subjectColors,
                darkBackColor,
                // backColor,
                theme,
                disableColor,
            );

            // define the CSS with the id of your menu
            insertCss(`
                .g6-component-contextmenu {
                position: absolute;
                z-index: 2;
                list-style-type: none;
                background-color: #363b40; 
                border-radius: 6px;
                font-size: 14px;
                color: hsla(0,0%,100%,.85);
                width: fit-content;
                transition: opacity .2s;
                text-align: center;
                padding: 0px 20px 0px 20px;
                    box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.6);
                    border: 0px;
            }
            .g6-component-contextmenu ul {
                    padding-left: 0px;
                    margin: 0;
            }
            .g6-component-contextmenu li {
                cursor: pointer;
                list-style-type: none;
                list-style: none;
                margin-left: 0;
                line-height: 38px;
            }
            .g6-component-contextmenu li:hover {
                color: #aaaaaa;
                }
            `);

            const global = {
                node: {
                    style: {
                        fill: '#2B384E',
                    },
                    labelCfg: {
                        style: {
                            fill: '#acaeaf',
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            fill: '#2B384E',
                        },
                    },
                },
                edge: {
                    style: {
                        stroke: '#acaeaf',
                        realEdgeStroke: '#acaeaf', //'#f00',
                        realEdgeOpacity,
                        strokeOpacity: realEdgeOpacity,
                    },
                    labelCfg: {
                        style: {
                            fill: '#acaeaf',
                            realEdgeStroke: '#acaeaf', //'#f00',
                            realEdgeOpacity: 0.5,
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            stroke: '#fff', // '#3C9AE8',
                        },
                    },
                },
            };

            // Custom real node
            G6.registerNode(
            'real-node',
            {
                draw(cfg, group) {
                let r = 30;
                if (isNumber(cfg.size)) {
                    r = cfg.size / 2;
                } else if (isArray(cfg.size)) {
                    r = cfg.size[0] / 2;
                }
                const style = cfg.style || {};
                const colorSet = cfg.colorSet || colorSets[0];

                // halo for hover
                group.addShape('circle', {
                    attrs: {
                    x: 0,
                    y: 0,
                    r: r + 5,
                    fill: style.fill || colorSet.mainFill || '#2B384E',
                    opacity: 0.9,
                    lineWidth: 0,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'halo-shape',
                    visible: false,
                });

                // focus stroke for hover
                group.addShape('circle', {
                    attrs: {
                    x: 0,
                    y: 0,
                    r: r + 5,
                    fill: style.fill || colorSet.mainFill || '#2B384E',
                    stroke: '#fff',
                    strokeOpacity: 0.85,
                    lineWidth: 1,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'stroke-shape',
                    visible: false,
                });

                const keyShape = group.addShape('circle', {
                    attrs: {
                    ...style,
                    x: 0,
                    y: 0,
                    r,
                    fill: colorSet.mainFill,
                    stroke: colorSet.mainStroke,
                    lineWidth: 2,
                    cursor: 'pointer',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'aggregated-node-keyShape',
                });

                let labelStyle = {};
                if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                }

                if (cfg.label) {
                    const text = cfg.label;
                    let labelStyle = {};
                    let refY = 0;
                    if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                    refY += cfg.labelCfg.refY || 0;
                    }
                    let offsetY = 0;
                    const fontSize = labelStyle.fontSize < 8 ? 8 : labelStyle.fontSize;
                    const lineNum = cfg.labelLineNum || 1;
                    offsetY = lineNum * (fontSize || 12);
                    group.addShape('text', {
                    attrs: {
                        text,
                        x: 0,
                        y: r + refY + offsetY + 5,
                        textAlign: 'center',
                        textBaseLine: 'alphabetic',
                        cursor: 'pointer',
                        fontSize,
                        fill: '#fff',
                        opacity: 0.85,
                        fontWeight: 400,
                        stroke: global.edge.labelCfg.style.stroke,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'text-shape',
                    className: 'text-shape',
                    });
                }

                // tag for new node
                if (cfg.new) {
                    group.addShape('circle', {
                    attrs: {
                        x: r - 3,
                        y: -r + 3,
                        r: 4,
                        fill: '#6DD400',
                        lineWidth: 0.5,
                        stroke: '#FFFFFF',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'typeNode-tag-circle',
                    });
                }

                return keyShape;
                },
                setState: (name, value, item) => {
                const group = item.get('group');
                if (name === 'layoutEnd' && value) {
                    const labelShape = group.find((e) => e.get('name') === 'text-shape');
                    if (labelShape) labelShape.set('visible', true);
                } else if (name === 'hover') {
                    if (item.hasState('focus')) {
                    return;
                    }
                    const halo = group.find((e) => e.get('name') === 'halo-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    halo && halo.show();
                    keyShape.attr('fill', colorSet.activeFill);
                    } else {
                    halo && halo.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                } else if (name === 'focus') {
                    const stroke = group.find((e) => e.get('name') === 'stroke-shape');
                    const label = group.find((e) => e.get('name') === 'text-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    stroke && stroke.show();
                    keyShape.attr('fill', colorSet.selectedFill);
                    label && label.attr('fontWeight', 800);
                    } else {
                    stroke && stroke.hide();
                    keyShape.attr('fill', colorSet.mainFill); // '#2B384E'
                    label && label.attr('fontWeight', 400);
                    }
                }
                },
                update: undefined,
            },
            'aggregated-node',
            ); // 这样可以继承 aggregated-node 的 setState
            
            const lineDash = [4, 2, 1, 2];
            G6.registerEdge(
            'line-dash',
            {
                afterDraw(cfg, group) {
                // get the first shape in the group, it is the edge's path here=
                const shape = group.get('children')[0];
                let index = 0;
                // Define the animation
                shape.animate(
                    () => {
                    index++;
                    if (index > 9) {
                        index = 0;
                    }
                    const res = {
                        lineDash,
                        lineDashOffset: -index,
                    };
                    // returns the modified configurations here, lineDash and lineDashOffset here
                    return res;
                    },
                    {
                    repeat: true, // whether executes the animation repeatly
                    duration: 3000, // the duration for executing once
                    },
                );
                },
            },
            'line', // extend the built-in edge 'cubic'
            );
            G6.registerEdge(
            'custom-quadratic',
            {
                setState: (name, value, item) => {
                const group = item.get('group');
                const model = item.getModel();
                if (name === 'focus') {
                    const back = group.find((ele) => ele.get('name') === 'back-line');
                    if (back) {
                    back.stopAnimate();
                    back.remove();
                    back.destroy();
                    }
                    const keyShape = group.find((ele) => ele.get('name') === 'edge-shape');
                    const arrow = model.style.endArrow;
                    if (value) {
                    if (keyShape.cfg.animation) {
                        keyShape.stopAnimate(true);
                    }
                    keyShape.attr({
                        strokeOpacity: animateOpacity,
                        opacity: animateOpacity,
                        stroke: '#fff',
                        endArrow: {
                        ...arrow,
                        stroke: '#fff',
                        fill: '#fff',
                        },
                    });
                    if (model.isReal) {
                        const { lineWidth, path, endArrow, stroke } = keyShape.attr();
                        const back = group.addShape('path', {
                        attrs: {
                            lineWidth,
                            path,
                            stroke,
                            endArrow,
                            opacity: animateBackOpacity,
                        },
                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                        name: 'back-line',
                        });
                        back.toBack();
                        const length = keyShape.getTotalLength();
                        keyShape.animate(
                        (ratio) => {
                            // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations
                            const startLen = ratio * length;
                            // Calculate the lineDash
                            const cfg = {
                            lineDash: [startLen, length - startLen],
                            };
                            return cfg;
                        },
                        {
                            repeat: true, // Whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    } else {
                        let index = 0;
                        const lineDash = keyShape.attr('lineDash');
                        const totalLength = lineDash[0] + lineDash[1];
                        keyShape.animate(
                        () => {
                            index++;
                            if (index > totalLength) {
                            index = 0;
                            }
                            const res = {
                            lineDash,
                            lineDashOffset: -index,
                            };
                            // returns the modified configurations here, lineDash and lineDashOffset here
                            return res;
                        },
                        {
                            repeat: true, // whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    }
                    } else {
                    keyShape.stopAnimate();
                    const stroke = '#acaeaf';
                    const opacity = model.isReal ? realEdgeOpacity : virtualEdgeOpacity;
                    keyShape.attr({
                        stroke,
                        strokeOpacity: opacity,
                        opacity,
                        endArrow: {
                        ...arrow,
                        stroke,
                        fill: stroke,
                        },
                    });
                    }
                }
                },
            },
            'quadratic',
            );
            //3、分类
            data.nodes.forEach(function (node) {
                const cid = clusterNode.indexOf(node.label);
                node.legendType=node.label;
                // node.type="real-node"
                node.labelType=node.label;
                node.label=null;
                if (!node.style) {
                    node.style = {};
                }
                node.size = nodeSize*node.pageRank;
                node.cluster = node.properties.cluster_id;
                node.style.fill = colorSets[node.cluster].mainFill;
                node.style.stroke = colorSets[node.cluster].mainStroke;
                // node.style.fill = colorSets[cid].mainStroke;
                // node.style.stroke = colorSets[cid].mainStroke;
            });

            data.edges.forEach(edge => {
                const cid = clusterEdge.indexOf(edge.label);
                edge.legendType=edge.label;
                edge.style = {
                    stroke: "#acaeaf",
                };
                //4.20新增
                edge.color = "#acaeaf";//"#9661BC"  //colorSets[cid].mainStroke;  //设置边的颜色
                edge.label=null;
            })


            var legendConfig = {}; 
            const nodeLegendSize = 15;
            var legendData = {}
            legendData.nodes = [];
            legendData.edges = [];
            var filterFunctions = {};

            const clusterMap = new Map();
            let clusterId = 0;
            data.nodes.forEach(function (node) {
            // cluster
                // if (node.cluster && clusterMap.get(node.properties.cluster_id) === undefined) {
                //     clusterMap.set(node.properties.cluster_id, clusterId);
                //     clusterId++;
                // }
                // const cid = clusterMap.get(node.properties.cluster_id);
                // if (!node.style) {
                //     node.style = {};
                // }
                // node.style.fill = colorSets[cid ].mainStroke;
                // node.style.stroke = colorSets[cid ].mainStroke;
            });

            clusterNode.forEach(element => {
                const cid = clusterNode.indexOf(element);
                // var nodeLegendConfig = {};
                // nodeLegendConfig["r"]=nodeLegendSize; //图例节点的大小
                // nodeLegendConfig["style"] = {
                //     "fill":colorSets[cid].mainStroke,
                //     "stroke":colorSets[cid].mainStroke //设置这个，不然node的边框会变成蓝色
                // };
                // legendConfig[element]=nodeLegendConfig;

                // legendData.nodes.push({
                //     id:element,
                //     label:element,
                //     ...legendConfig[element]
                // })
                filterFunctions[element] = (d)=>{if (d.legendType === element) return true;return false}
            });

            clusterEdge.forEach(element=>{
                const cid = clusterEdge.indexOf(element);
                // var edgeLegendConfig = {};
                // edgeLegendConfig["type"]="line"; //图例节点的大小
                // edgeLegendConfig["style"]={"stroke":colorSets[cid].mainStroke,"width":20};
                // legendConfig[element]=edgeLegendConfig;

                // legendData.edges.push({
                //     id: element,
                //     label: element,
                //     ...legendConfig[element]
                // })
                // filterFunctions[element] = (d)=>{if (d.legendType === element) return true;return false}
            })
            // console.log(filterFunctions)
            //     data: legendData,
            //     align: 'center',
            //     layout: 'vertical', // vertical  图标水平或竖直  horizontal
            //     position: 'bottom-left',  //TODO: 图标的位置原本为bottom-left
            //     vertiSep: 10, //12竖直间距
            //     horiSep: 20, //图例间的水平间距
            //     offsetX: 10, //图例区域离 position 对应的默认位置的 x 方向的偏移量，可被用于图例位置的微调
            //     offsetY: -10,
            //     padding: [12, 4, 8, 16], //图例区域内部内容到边框的距离，四位数组分别代表上、右、下、左边距
            //     containerStyle: {
            //         fill: '#ccc',
            //         lineWidth: 1
            //     },
            //     title: '',
            //     titleConfig: {
            //         position: 'center',
            //         offsetX: 0,
            //         offsetY: 12,
            //     },
            //     filter: {
            //         enable: true,
            //         trigger: 'mouseenter',
            //         graphActiveState: 'activeByLegend',
            //         graphInactiveState: 'inactiveByLegend',
            //         filterFunctions: filterFunctions
            //     }
            // });

            //tooltip 悬浮提示框
            
            let hiddenItemIds = []; // 隐藏的元素 id 数组
            let expandArray = [];
            let collapseArray = [];
            let newAddArray = [];

            //方法区
            const hideItems = (graph) => {
                hiddenItemIds.forEach((id) => {
                    graph.hideItem(id);
                });
            };

            const showItems = (graph) => {
                graph.getNodes().forEach((node) => {
                    if (!node.isVisible()) graph.showItem(node);
                });
                graph.getEdges().forEach((edge) => {
                    if (!edge.isVisible()) edge.showItem(edge);
                });
                hiddenItemIds = [];
            };

            const processNodeAndEdge = (data)=>{
                data.nodes.forEach((node)=>{
                        if(!graph.findById(node.id)){
                            newAddArray.push(node.id);
                            console.log("not find",node.id)
                            node.legendType=node.label;
                            if (!node.style) {
                                node.style = {};
                            }
                            node.icon = {
                                show:true,
                                img:require("@/assets/nodes/"+node.label+".png"),
                                // img:require("@/assets/nodes/Redirect.png"),
                            }
                            node.style.fill = "#2B384E";
                            node.style.stroke = "#2B384E";
                            console.log("add",node.id)
                            graph.addItem('node',node );
                        }
                    })
                    data.edges.forEach((edge)=>{
                        edge.label=null;
                        const rs = graph.find("edge",(oedge)=>{
                            return oedge.get('model').source==edge.source&& oedge.get('model').target==edge.target;
                        })
                        console.log(rs)
                        if(!rs){
                            edge.id = 'edge' + edge.id;
                            graph.addItem('edge',edge );
                        }
                        // 
                    })
            }

            const findNeighbors = (graph,model,depth=1) =>{
                fetch("api/graph/domain?dname="+model.properties.name+"&depth="+depth)
                .then((res) => res.json())
                .then((data) => {
                    processNodeAndEdge(data);
                    // data.nodes.forEach((node)=>{
                    //     if(!graph.findById(node.id)){
                    //         newAddArray.push(node.id);
                    //         console.log("not find",node.id)
                    //         node.legendType=node.label;
                    //         if (!node.style) {
                    //             node.style = {};
                    //         }
                    //         node.icon = {
                    //             show:true,
                    //             img:require("@/assets/nodes/"+node.label+".png"),
                    //             // img:require("@/assets/nodes/Redirect.png"),
                    //         }
                    //         node.style.fill = "#2B384E";
                    //         node.style.stroke = "#2B384E";
                    //         console.log("add",node.id)
                    //         graph.addItem('node',node );
                    //     }
                    // })
                    // data.edges.forEach((edge)=>{
                    //     edge.label=null;
                    //     const rs = graph.find("edge",(oedge)=>{
                    //         return oedge.get('model').source==edge.source&& oedge.get('model').target==edge.target;
                    //     })
                    //     console.log(rs)
                    //     if(!rs){
                    //         edge.id = 'edge' + edge.id;
                    //         graph.addItem('edge',edge );
                    //     }
                    //     // 
                    // })
                    
                })
            }

            const findCompanyByPerson = () =>{
                fetch("api/graph/domain?dname="+model.properties.name+"&depth="+depth)
                .then((res) => res.json())
                .then((data) => {
                    processNodeAndEdge(data);
                })
            }

            const findCompanyByWebsite = () =>{
                fetch("api/graph/domain?dname="+model.properties.name+"&depth="+depth)
                .then((res) => res.json())
                .then((data) => {
                    processNodeAndEdge(data);
                })
            }
            const findWebsitesByCompany = () =>{
                fetch("api/graph/findWebsitesByCompany?name="+model.properties.name)
                .then((res) => res.json())
                .then((data) => {
                    processNodeAndEdge(data);
                })
            }


            const clickNode=(id)=>{
                const filteredData = this.graphData.nodes.filter(item => {
                    return item.id==id;
                })
                this.tableData = filteredData;
            };
            //菜单 
            const contextMenu = new G6.Menu({
                shouldBegin(evt) {
                    if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) return true;
                    if (evt.item) return true;
                    return false;
                },
                getContent(evt) {
                    const { item } = evt;
                    let header;
                    if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) { //右键画布
                        return `<ul>
                        <li id='show'>显示全部隐藏节点</li>
                        <li id='collapseAll'>Collapse all Clusters</li>
                        </ul>`;
                    } 
                    else if (!item) return;
                    const itemType = item.getType();
                    const model = item.getModel();
                    if (itemType && model) {
                        var basicMenu = `
                                <ul>
                                    <li id='expand'>展开一度关联节点</li>
                                    <li id='expand2'>展开二度关联节点</li>
                                    <li id='hideNeighbor'>折叠关联节点</li>
                                    <li id='hide'>隐藏节点</li>
                                </ul>`;
                        if (itemType == 'node') { //右键节点
                            if(model.labelType=="Website"){
                                var menu = `
                                <ul>
                                    <li id='findCompanyByWebsite'>追踪所属公司</li>
                                    <li id='expand'>展开一度关联节点</li>
                                    <li id='expand2'>展开二度关联节点</li>
                                    <li id='hideNeighbor'>折叠关联节点</li>
                                    <li id='hide'>隐藏节点</li>
                                </ul>`;
                                return menu;
                            }else if(model.labelType=="Person"){
                                var menu = `
                                <ul>
                                    <li id='findCompanyByPerson'>追踪所属公司</li>
                                    <li id='expand'>展开一度关联节点</li>
                                    <li id='expand2'>展开二度关联节点</li>
                                    <li id='hideNeighbor'>折叠关联节点</li>
                                    <li id='hide'>隐藏节点</li>
                                </ul>`;
                                return menu;
                            }else if(model.labelType=="Company"){
                                var menu = `
                                <ul>
                                    <li id='findPerson'>追踪所属人员</li>
                                    <li id='findWebsitesByCompany'>追踪旗下网站<li>
                                    <li id='expand'>展开一度关联节点</li>
                                    <li id='expand2'>展开二度关联节点</li>
                                    <li id='hideNeighbor'>折叠关联节点</li>
                                    <li id='hide'>隐藏节点</li>
                                </ul>`;
                                return menu;
                            }

                            return `
                                <ul>
                                    <li id='expand'>展开一度关联节点</li>
                                    <li id='expand'></li>
                                    <li id='expand2'>展开二度关联节点</li>
                                    <li id='hideNeighbor'>折叠关联节点</li>
                                    <li id='hide'>隐藏节点</li>
                                </ul>`;
                        }
                    }
                },
                handleMenuClick: (target, item) => {
                    const model = item && item.getModel();
                    const liIdStrs = target.id.split('-');
                    let mixedGraphData;
                    switch (liIdStrs[0]) {
                    case 'hide':
                        graph.hideItem(item);
                        hiddenItemIds.push(model.id);
                        break;
                    case 'expand':
                        findNeighbors(graph,model)
                        break;
                    case 'expand2':
                        findNeighbors(graph,model,2)
                            break;
                    case 'findCompanyByWebsite':
                        findCompanyByWebsite(graph,model)
                        break;
                    case 'findCompanyByPerson':
                        findCompanyByPerson(graph,model)
                        break;
                    case 'findWebsitesByCompany':
                        findWebsitesByCompany(graph,model)
                        break;
                    case 'collapse':
                        const aggregatedNode = aggregatedNodeMap[model.clusterId];
                        manipulatePosition = { x: aggregatedNode.x, y: aggregatedNode.y };
                        collapseArray.push(aggregatedNode);
                        for (let i = 0; i < expandArray.length; i++) {
                            if (expandArray[i].id === model.clusterId) {
                                expandArray.splice(i, 1);
                                break;
                            }
                        }
                        mixedGraphData = getMixedGraph(
                            clusteredData,
                            data,
                            nodeMap,
                            aggregatedNodeMap,
                            expandArray,
                            collapseArray,
                        );
                        break;
                    case 'collapseAll':
                        newAddArray.forEach(id=>{
                            graph.hideItem(id)
                        });
                        break;
                    case 'neighbor':
                        const expandNeighborSteps = parseInt(liIdStrs[1]);
                        mixedGraphData = getNeighborMixedGraph(
                            model,
                            expandNeighborSteps,
                            data,
                            clusteredData,
                            currentUnproccessedData,
                            nodeMap,
                            aggregatedNodeMap,
                            10,
                        );
                        break;
                    case 'hideNeighbor':
                        const node = graph.findById(model.id);
                        const neightborList = node.getNeighbors()
                        neightborList.forEach(element=>{
                            const id = element.getModel().id
                            graph.hideItem(id)
                            hiddenItemIds.push(id); //将邻居节点id加入隐藏数组
                        })
                        //隐藏节点本身
                        graph.hideItem(item);
                        hiddenItemIds.push(model.id);
                        break;
                    case 'show':
                        showItems(graph);
                        break;
                    default:
                        break;
                    }
                    if (mixedGraphData) {
                        cachePositions = cacheNodePositions(graph.getNodes());
                        currentUnproccessedData = mixedGraphData;
                        handleRefreshGraph(
                            graph,
                            currentUnproccessedData,
                            CANVAS_WIDTH,
                            CANVAS_HEIGHT,
                            largeGraphMode,
                            true,
                            false,
                        );
                    }
            },
                // offsetX and offsetY include the padding of the parent container
                // 需要加上父级容器的 padding-left 16 与自身偏移量 10
                offsetX: 16 + 10,
                // 需要加上父级容器的 padding-top 24 、画布兄弟元素高度、与自身偏移量 10
                offsetY: 0,
                // the types of items that allow the menu show up
                // 在哪些类型的元素上响应
                itemTypes: ['node', 'edge', 'canvas'],
            });

            const nodes = this.graphData.nodes;
            const onTick = () => {
            let minx = 99999999;
            let maxx = -99999999;
            let miny = 99999999;
            let maxy = -99999999;
            let maxsize = -9999999;
            nodes.forEach((node) => {
                if (minx > node.x) {
                minx = node.x;
                }
                if (maxx < node.x) {
                maxx = node.x;
                }
                if (miny > node.y) {
                miny = node.y;
                }
                if (maxy < node.y) {
                maxy = node.y;
                }
                if (maxsize < node.size) {
                maxsize = node.size;
                }
            });
            const scalex = (constrainBox.width - maxsize) / (maxx - minx);
            const scaley = (constrainBox.height - maxsize) / (maxy - miny);
            nodes.forEach((node) => {
                node.x = (node.x - minx) * scalex + constrainBox.x;
                node.y = (node.y - miny) * scaley + constrainBox.y;
            });
            };

            const graph = new G6.Graph({
                container: containerId,
                width,   
                height,
                // fitView:true, 别开最好
                //TODO:注意 fitCenter和layout中的center只选择一个
                fitCenter: true,
                // linkCenter: true,
                modes: {
                    default: ['drag-canvas', 'zoom-canvas','drag-node']
                },
                layout: {
                    // type: 'force',
                    // linkDistance: 60, //边的长度 180
                    // preventOverlap: true,
                    // nodeStrength: (d) => {
                    // if (d.isLeaf) {
                    //     return -10;
                    // }
                    // return -5;
                    // },

                    // nodeStrength: nodeStrength,  //节点的引力，负数代表斥力
                    // center: [width / 2, height / 2],// 可选，默认为图的中心


                    type: 'force',
                    clustering: true,
                    clusterNodeStrength: -5,
                    clusterEdgeDistance: 200,
                    clusterNodeSize: 20,
                    clusterFociStrength: 1.2,


                    nodeSpacing: 5,
                    preventOverlap: true,
                    // type: 'force',
                    // onTick,

    //                 type: 'force2',
    // animate: false, // 设置为 false 可关闭布局动画
    // maxSpeed: 100,
    // linkDistance: 50,
    // clustering: true,
    // nodeClusterBy: 'cluster_id',
    // clusterNodeStrength: 300,

                },
                nodeSpacing:13,
                defaultNode: {
                    size:20,
                    // size: nodeSize,
                    type: 'circle',
                    style: {
                        lineWidth: 2,
                    },
                    labelCfg: {
                        position: 'bottom',
                        style: {
                            fill: '#FFF',
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                    },
                    
                },
                defaultEdge: {
                    color:"#acaeaf",
                    style:{  //TODO:可以修改箭头的样式  https://g6.antv.antgroup.com/manual/middle/elements/edges/arrow
                        realEdgeOpacity,
                        strokeOpacity: realEdgeOpacity,
                        lineWidth:lineWidth,
                    },
                    labelCfg: {
                        style: {
                            fill: '#acaeaf',
                            realEdgeStroke: '#acaeaf', //'#f00',
                            realEdgeOpacity: 0.5,
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            stroke: '#fff', // '#3C9AE8',
                        },
                    },
                },
                nodeStateStyles: {
                    focus: {
                        stroke: '#fff',
                        lineWidth: 10,
                        strokeOpacity: 0.5
                    },
                    activeByLegend: {
                        lineWidth: 10,
                        strokeOpacity: 0.5
                    },
                    inactive:{ //必须设置这个，否则node样式会变化
                        fill:"#2B384E",
                        stroke:"#2B384E"
                    },
                    hover:{
                        fill: colorSets[0].mainStroke  || colorSets[0].mainStroke  || '#2B384E',
                        strokeOpacity: 0.5,
                        lineWidth: 10,
                        stroke: '#fff',
                    },
                    normal:{
                            fill:colorSets[0].mainStroke,
                            stroke:colorSets[0].mainStroke
   
                    }
                },
                edgeStateStyles: {
                    activeByLegend: {
                        lineWidth: 3
                    },
                    inactiveByLegend: {
                        opacity: 0.5
                    },
                    focus: {
                        stroke: '#fff', // '#3C9AE8',
                    },
                    normal:{
                        stroke: "#acaeaf",
                    }
                },
                // animate: true,
                plugins: [contextMenu],
            });
            this.graph = graph;
            graph.data({
                nodes: data.nodes,
                edges: data.edges.map(function (edge, i) {
                    // edge.id = 'edge' + i;
                    edge.id = 'edge' + edge.id;
                    return Object.assign({}, edge);
                }),
            });
            graph.render();
            const handleClear = ()=>{
                this.handleClear()
            }
            const clearFocusItemState = (graph) => {
                if (!graph) return;
                clearFocusNodeState(graph);
                clearFocusEdgeState(graph);
            };
            // 清除图上所有节点的 focus 状态及相应样式
            const clearFocusNodeState = (graph) => {
                const focusNodes = graph.findAllByState('node', 'focus');
                focusNodes.forEach((fnode) => {
                    graph.setItemState(fnode, 'focus', false); // false
                });
            };

            // 清除图上所有边的 focus 状态及相应样式
            const clearFocusEdgeState = (graph) => {
                const focusEdges = graph.findAllByState('edge', 'focus');
                focusEdges.forEach((fedge) => {
                    graph.setItemState(fedge, 'focus', false);
                });
            };

            graph.on('node:click', function (e) {
                // alert(e.item.get('model').id)
                const { item } = e;
                //先清除focus样式
                clearFocusItemState(graph);
                //设置节点focus样式
                graph.setItemState(item, 'focus', true);
                //高亮相关边
                const relatedEdges = item.getEdges();
                relatedEdges.forEach((edge) => {
                    // edge.getModel().type="line-dash";
                    // edge.getModel().style={
                    //     lineWidth: 2,
                    //     stroke: '#bae7ff',
                    // };
                     // 定义动画效果
                    
                    graph.setItemState(edge, 'focus', true);
                });
                clickNode(e.item.get('model').id) //增加动画扩散效果-边；取消选中
                console.log(e.item.get('model'))
            });
            //hover
            graph.on('node:mouseenter', (evt) => {
                const { item } = evt;
                const model = item.getModel();
                const currentLabel = model.label;
                model.oriFontSize = model.labelCfg.style.fontSize;
                item.update({
                label: model.oriLabel,
                });
                model.oriLabel = currentLabel;
                graph.setItemState(item, 'hover', true);
                item.toFront();
            });
            graph.on('node:mouseleave', (evt) => {
                const { item } = evt;
                graph.setItemState(item, 'hover', false);
            });
            //也不对，也不能每点一次canvas就重设状态，当有node被选中时再说
            graph.on('canvas:click', function (e) {
                // alert("canvas")
                handleClear()
                clearFocusItemState(graph);
                // this.tableData=this.graphData.nodes.slice(0,10)
            });

            graph.on('afteradditem',function (e) {
                console.log("after add回调函数")
            //     graph.updateLayout({
            //         nodeSpacing: 5,
            //         preventOverlap: true,
            //         // kr: 10,
            //         type: 'force',
            //         onTick,
            // });
                // onTick();
                graph.layout();
                refreshDragedNodePosition(e);
            });

            if (typeof window !== 'undefined')
            window.onresize = () => {
                if (!graph || graph.get('destroyed')) return;
                if (!container || !container.scrollWidth || !container.scrollHeight) return;
                graph.changeSize(container.scrollWidth, container.scrollHeight);
            };

            function refreshDragedNodePosition(e) {
                const model = e.item.get('model');
                model.fx = e.x;
                model.fy = e.y;
            }
        },
        clusterLayout(){
            this.graph.updateLayout({
                type: 'force',
                    clustering: true,
                    clusterNodeStrength: -5,
                    clusterEdgeDistance: 200,
                    clusterNodeSize: 20,
                    clusterFociStrength: 1.2,
            });
        },
        clickWebsiteButton(item){
            //清除原本的focus样式
            const focusNodes = this.graph.findAllByState('node', 'focus');
            focusNodes.forEach((fnode) => {
                this.graph.setItemState(fnode, 'focus', false); // false
            });
            const focusEdges = this.graph.findAllByState('edge', 'focus');
            focusEdges.forEach((fedge) => {
                this.graph.setItemState(fedge, 'focus', false);
            });
                        //focus点击的节点样式
            const node = this.graph.findById(item.id)
            this.graph.setItemState(node, 'focus', true);
            const relatedEdges = node.getEdges();
            relatedEdges.forEach((edge) => {
                this.graph.setItemState(edge, 'focus', true);
            });
        },
        
        showWebsiteColumn(){

        },
        changeFold() {
            this.fold = !this.fold;
            console.log(this.fold)
            if(this.fold){ //折叠时
                this.sideWidth="0px"
                this.iconType="el-icon-arrow-right";
            }else{  //不折叠时
                this.sideWidth="340px"
                this.iconType="el-icon-arrow-left";
            }
        
        },
        expandLeftSide(){
            this.expandLeft = !this.expandLeft;
            if(this.expandLeft==false){  //不拓展左侧栏
                this.expandButtonText="展开"
                this.sideWidth="340px"
            }else{ //拓展左侧栏
                this.expandButtonText="收起"
                this.sideWidth="600px"
            }
        },
    },
    mounted(){
        this.getAllWebsites()
    }
}
</script>

<style lang="scss" scoped>

    .el-input{
        width: 210px;
    }

    
    .nodeBox{
        height:90px;
        background:#505050;
        border-bottom: 0.3px solid #979696;
        padding: 10px;
        color:white;
        border-radius: 5px;
        

        .custom-button{
            color: #fff;font-size:12px;font-weight:700;
            display: inline-block;
        }
        .custom-button:hover{
            opacity:0.9;
            color: #fefa86;font-size:12px;font-weight:700;
        }
        .span{
            display: inline-block;
        }
    }
    .nodeBox:hover{
        background:#636262;
    }

    .side-pane-main {
        width:100%;
        z-index:1;
        margin-left: 0;
    }

    .side-pane-left {
        z-index:3;
        position: absolute;
        height: 100%;
        top: 0;
        left: 0;
        box-shadow: 10px 0px 5px -5px rgba(0, 0, 0, 0.526);
        //border-right: 1px solid #d7dae2;
        transition: width 0.3s;
        padding: 20px;
        background: #444343;
        opacity: 0.99;
        .fold-btn{
            z-index:4;
            position:absolute;
            right: -40px; //和宽度的长度相同
            top:0px;
            width:40px;
            height:40px;
            background: white;
            box-shadow: 0 4px 12pxrgba(0,0,0,.19) !important;
             visibility: visible;
        }

        .expand-button{
            float: right;
        }
       

    }
    .side-pane-main {
        z-index:1;
        position: relative;
        transition: all 0.3s;

        .side-pane-main-header {
            box-sizing: border-box;
            min-height: 40px;
            padding: 8px 20px;
            border-bottom: 1px solid #d7dae2;
        }

        .side-pane-main-body {
            padding: 8px 20px;
        }
    }

    .group-graph{
        scrollWidth:800px;
        scrollHeight:700px;
    }


</style>