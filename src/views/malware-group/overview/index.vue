<template>
    <div class="page">
        <el-row>
            <el-card>
                 <div style="font-size: 20px;margin-bottom: 7px;">团伙全局溯源</div>
                 <span>追踪团伙构成恶意下载网站、背后公司组成、涉及人员</span>
            </el-card>
        </el-row>

        <el-row :gutter="5">
            <el-col :span="15">
                <el-card class="group-container">
                    <el-row :gutter="20">
                        <el-col :span="12">
                          <div style="color:white">
                            <el-statistic group-separator="," decimal-separator="." :value="groupCount" title="团伙总数">
                              <template slot="prefix">
                                <i class="el-icon-s-flag" style="color: red"></i>
                              </template>
                              {{ groupCount }}
                            </el-statistic>
                          </div>
                        </el-col>

                        <el-col :span="12">
                          <div>
                            <el-statistic :value="0" title="今日新增团伙">
                            </el-statistic>
                          </div>
                        </el-col>
                      </el-row>
                      <el-divider></el-divider>
                    <div id="group-container" ></div>
                </el-card>
                
            </el-col>   
            <el-col :span="9">
                <el-card class="timeline-card">
                    <span>团伙时间轴</span>
                    <el-scrollbar style="height:510px;" wrap-style="overflow-x:hidden;">
                    <div class="timeline-container">
                        <a-timeline mode="alternate" style="margin-top:5px;" >
                            <a-timeline-item>Create a services site 2015-09-01</a-timeline-item>
                            <a-timeline-item color="green">
                                Create a services site 2015-09-01
                            </a-timeline-item>
                            <a-timeline-item  color="green">
                                Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque
                                laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto
                                beatae vitae dicta sunt explicabo.
                            </a-timeline-item>
                            <a-timeline-item color="red">
                                Network problems being solved 2015-09-01
                            </a-timeline-item>
                            <a-timeline-item>Create a services site 2015-09-01</a-timeline-item>
                            <a-timeline-item  color="green">
                                Technical testing 2015-09-01
                            </a-timeline-item>
                            <a-timeline-item  color="green">
                                Technical testing 2015-09-01
                                </a-timeline-item>
                                <a-timeline-item  color="green">
                                Technical testing 2015-09-01
                                </a-timeline-item>
                                <a-timeline-item  color="green">
                                Technical testing 2015-09-01
                                </a-timeline-item>
                        </a-timeline>
                    </div>
                    </el-scrollbar>
                </el-card>
            </el-col>
        </el-row>

        <el-row :gutter="5">
            <el-col :span="12">
                <el-card style="height:400px">
                    团伙规模排名
                    <!-- <div id="rank-container" style="height:400px">
                    </div> -->
                    <el-row>
                        <el-col :span="8">
                            <svg t="1683434934151" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7161" width="60" height="60"><path d="M287.762 124.318v252.871c0 123.331 100.905 224.238 224.238 224.238 123.331 0 224.238-100.907 224.238-224.238V124.318H287.762z" fill="#82A0AF" p-id="7162"></path><path d="M379.487 124.318v149.434c0 72.882 59.63 132.513 132.513 132.513 72.882 0 132.513-59.631 132.513-132.513V124.318H379.487z" fill="#E0EAED" p-id="7163"></path><path d="M644.513 124.318v149.434c0 72.882-59.631 132.514-132.513 132.514-72.884 0-132.514-59.631-132.514-132.514V124.318h265.027m19.201-19.201H360.285v168.635c0 83.656 68.059 151.714 151.715 151.714s151.714-68.059 151.714-151.714V105.117z" fill="#FFFFFF" p-id="7164"></path><path d="M512 622.736m-339.055 0a339.055 339.055 0 1 0 678.11 0 339.055 339.055 0 1 0-678.11 0Z" fill="#9EC2F7" p-id="7165"></path><path d="M512 622.736m-250.074 0a250.074 250.074 0 1 0 500.148 0 250.074 250.074 0 1 0-500.148 0Z" fill="#DDECF7" p-id="7166"></path><path d="M512 372.662c138.112 0 250.074 111.962 250.074 250.074S650.112 872.81 512 872.81c-138.113 0-250.074-111.962-250.074-250.074S373.888 372.662 512 372.662m0-24.001c-151.126 0-274.075 122.95-274.075 274.075S360.874 896.811 512 896.811s274.075-122.95 274.075-274.076S663.126 348.661 512 348.661z" fill="#FFFFFF" p-id="7167"></path><path d="M786.015 124.319h-548.03c-17.08 0-31.055-13.975-31.055-31.055s13.975-31.055 31.055-31.055h548.029c17.08 0 31.055 13.975 31.055 31.055 0.001 17.08-13.974 31.055-31.054 31.055z" fill="#231815" p-id="7168"></path><path d="M623.478 748.689v42.438h-218.7v-34.684l128.12-130.562c13.599-13.599 23.256-25.839 28.97-36.723 5.71-10.875 8.569-22.576 8.569-35.092 0-17.949-5.241-32.233-15.708-42.836-10.477-10.613-24.685-15.915-42.639-15.915-16.594 0-30.465 4.285-41.617 12.849-11.157 8.569-19.177 20.748-24.071 36.517l-37.947-22.435c7.346-22.576 19.993-39.785 37.947-51.616 17.949-11.832 40.394-17.752 67.32-17.752 20.945 0 39.644 4.285 56.102 12.854 16.454 8.569 29.237 20.542 38.355 35.908 9.108 15.371 13.669 32.711 13.669 52.024 0 18.498-4.631 35.43-13.876 50.796-9.249 15.371-24.343 33.803-45.288 55.287l-86.09 88.944h146.884z" p-id="7169"></path></svg>
                             第二
                        </el-col>
                        <el-col :span="8">
                            <svg t="1683434877888" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6052" data-spm-anchor-id="a313x.7781069.0.i0" width="60" height="60"><path d="M287.762 124.318v252.871c0 123.331 100.905 224.238 224.238 224.238 123.331 0 224.238-100.907 224.238-224.238V124.318H287.762z" fill="#D81919" p-id="6053"></path><path d="M379.487 124.318v149.434c0 72.882 59.63 132.513 132.513 132.513 72.882 0 132.513-59.631 132.513-132.513V124.318H379.487z" fill="#FACC60" p-id="6054"></path><path d="M644.513 124.318v149.434c0 72.882-59.631 132.514-132.513 132.514-72.884 0-132.514-59.631-132.514-132.514V124.318h265.027m19.201-19.201H360.285v168.635c0 83.656 68.059 151.714 151.715 151.714s151.714-68.059 151.714-151.714V105.117z" fill="#FFFFFF" p-id="6055"></path><path d="M512 622.736m-339.055 0a339.055 339.055 0 1 0 678.11 0 339.055 339.055 0 1 0-678.11 0Z" fill="#F8B643" p-id="6056"></path><path d="M512 622.736m-250.074 0a250.074 250.074 0 1 0 500.148 0 250.074 250.074 0 1 0-500.148 0Z" fill="#FFF89F" p-id="6057"></path><path d="M512 372.662c138.112 0 250.074 111.962 250.074 250.074S650.112 872.81 512 872.81c-138.113 0-250.074-111.962-250.074-250.074S373.888 372.662 512 372.662m0-24.001c-151.126 0-274.075 122.95-274.075 274.075S360.874 896.811 512 896.811s274.075-122.95 274.075-274.076S663.126 348.661 512 348.661z" fill="#FFFFFF" p-id="6058"></path><path d="M786.015 124.319h-548.03c-17.08 0-31.055-13.975-31.055-31.055s13.975-31.055 31.055-31.055h548.029c17.08 0 31.055 13.975 31.055 31.055 0.001 17.08-13.974 31.055-31.054 31.055z" fill="#231815" p-id="6059"></path><path d="M556.594 800.727h-51.41V527.763l-68.956 39.578 0.408-51.41 82.827-48.147h37.131v332.943z" p-id="6060"></path></svg>
                           
                            第一
                        </el-col>
                        <el-col :span="8">
                            <svg t="1683434958123" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7966" width="60" height="60"><path d="M287.762 124.318v252.871c0 123.331 100.905 224.238 224.238 224.238 123.331 0 224.238-100.907 224.238-224.238V124.318H287.762z" fill="#BF4C19" p-id="7967"></path><path d="M379.487 124.318v149.434c0 72.882 59.63 132.513 132.513 132.513 72.882 0 132.513-59.631 132.513-132.513V124.318H379.487z" fill="#DC8C57" p-id="7968"></path><path d="M644.513 124.318v149.434c0 72.882-59.631 132.514-132.513 132.514-72.884 0-132.514-59.631-132.514-132.514V124.318h265.027m19.201-19.201H360.285v168.635c0 83.656 68.059 151.714 151.715 151.714s151.714-68.059 151.714-151.714V105.117z" fill="#FFFFFF" p-id="7969"></path><path d="M512 622.736m-339.055 0a339.055 339.055 0 1 0 678.11 0 339.055 339.055 0 1 0-678.11 0Z" fill="#FCC181" p-id="7970"></path><path d="M512 622.736m-250.074 0a250.074 250.074 0 1 0 500.148 0 250.074 250.074 0 1 0-500.148 0Z" fill="#FFE6BF" p-id="7971"></path><path d="M512 372.662c138.112 0 250.074 111.962 250.074 250.074S650.112 872.81 512 872.81c-138.113 0-250.074-111.962-250.074-250.074S373.888 372.662 512 372.662m0-24.001c-151.126 0-274.075 122.95-274.075 274.075S360.874 896.811 512 896.811s274.075-122.95 274.075-274.076S663.126 348.661 512 348.661z" fill="#FFFFFF" p-id="7972"></path><path d="M786.015 124.319h-548.03c-17.08 0-31.055-13.975-31.055-31.055s13.975-31.055 31.055-31.055h548.029c17.08 0 31.055 13.975 31.055 31.055 0.001 17.08-13.974 31.055-31.054 31.055z" fill="#231815" p-id="7973"></path><path d="M627.439 699.539c0 20.677-4.692 39.105-14.077 55.287-9.385 16.187-22.51 28.764-39.372 37.741-16.871 8.977-36.18 13.468-57.94 13.468-25.843 0-48.082-5.916-66.711-17.752-18.634-11.832-31.351-28.079-38.148-48.757l37.947-22.44c5.161 14.687 13.463 26.11 24.887 34.272 11.424 8.161 25.431 12.24 42.025 12.24 18.493 0 33.386-5.916 44.678-17.748 11.283-11.832 16.932-27.264 16.932-46.31 0-19.585-5.649-34.947-16.932-46.104-11.293-11.152-26.725-16.73-46.31-16.73-19.857 0-34.68 6.394-44.472 19.177l-28.97-31.417 108.53-113.836H424.654v-42.846h187.691v34.684l-86.91 91.804c19.585 0.272 37.131 4.894 52.633 13.871 15.507 8.977 27.606 21.423 36.316 37.333 8.7 15.914 13.055 33.938 13.055 54.063z" p-id="7974"></path></svg>
                            第三
                        </el-col>
                    </el-row>
                    <el-scrollbar style="height:250px;"  wrap-style="overflow-x:hidden;">
                        <el-table :data="clusterCountList" size="small" class="tableBox"  style="width: 100%" >
                            <el-table-column prop="id" label="排名" type="index"></el-table-column>
                            
                            <el-table-column prop="count" :show-overflow-tooltip=true label="成员数量"></el-table-column>
                        
                            <el-table-column prop="count" label="团伙规模" :show-overflow-tooltip=true>
                                <template slot-scope="scope">
                                    <el-tag size="mini" disable-transitions>大团伙</el-tag>
                                </template>
                            </el-table-column>
                
                            <el-table-column prop="id" :show-overflow-tooltip=true label="团伙id"></el-table-column>
                            
                        </el-table>
                    </el-scrollbar>
                    
                <!-- <div class="block" style="margin-top:1px">
                    <el-pagination
                      layout="prev, pager, next"
                      @current-change="handleCurrentChange"
                      :current-page.sync="currentPage"
                      :page-size="pageSize"
                      :total="total()"
                      >
                    </el-pagination>
                </div> -->
                </el-card>
                
            </el-col>
            <el-col :span="12">
                <el-card  style="height:400px">
                    团伙增长情况
                    <div id="bubble-container" style="height:400px"></div>
                </el-card>
            </el-col>
        </el-row>

      
    </div>
</template>

<script>

import G6 from '@antv/g6';
import insertCss from 'insert-css';
import { isNumber, isArray } from '@antv/util';
import { Column } from '@antv/g2plot';
import { Scatter } from '@antv/g2plot';
import { objectEntries } from '@vueuse/core';


export default {
    components: {

    },
    data(){
        return{
            graphData:'',
            cid:'',
            groupCount:'',
            clusterCountList:'',
        }
    },
    methods:{ 
        getAllWebsites(){
            const limit = 300;
            var url = 'api/graph/websites?limit='+limit+'&wname=';
            var all='api/graph/websites?limit='+'&wname=';
            this.axios({
                url:all,
                method:'get'
            }).then(res=>{
                // this.$store.commit('setGraphData', res.data)
                this.graphData = res.data;
                return this.showmy()
            })
        },
        showmy(){
            //默认只展示团伙聚类的椭圆，椭圆之间可以有边，最多2条，根据其中包含网站之间的边构建；
            //点开展开聚类之后，展示具体其中网站和其他簇的边，cluster节点不消失，以便将它包含的网站连接起来；但是cluster和其他cluster的边消失了。
            //点击折叠团伙后，恢复初始状态

            //1.首先获取所有的类别数量，创建Cluster节点
            //let nodes = [{"cluster_id":1},{"cluster_id":2},{"cluster_id":3},{"cluster_id":1},{"cluster_id":1},{"cluster_id":2}];
            let clusterCounts = {};
            let clusterCountList = [];
            for (let node of this.graphData.nodes) {
                let clusterId = node.properties.cluster_id;
                if (clusterId in clusterCounts) {
                    clusterCounts[clusterId]++;
                } else {
                    clusterCounts[clusterId] = 1;
                }
            }
            for(var key of Object.keys(clusterCounts)){
                clusterCountList.push({"id":key,"count":clusterCounts[key]});
            }
            const result = clusterCountList.sort((a, b) => b.count - a.count);
            console.log(result)
            this.clusterCountList=result;
            this.groupCount= Object.keys(clusterCounts).length;
            


            // 1.1 将nodes数组转换为以id为键的JavaScript对象
            let clusterData = [];
            clusterData.clusters=[];
            clusterData.clusterEdges=[];
            const nodesById = {};
            //cluster节点
            for(let node of this.graphData.nodes){
                nodesById[node.id] = node;
                //给每个node添加level=0属性
                node.level=0;
                node.clusterId = "c"+node.properties.cluster_id
                //如果没出现过这个类别，就把这个类别加进去
                var cluster = clusterData.clusters.find(c=>c.id === node.properties.cluster_id);
                if(!cluster){ //若目前不存在此cluster，则创建
                    let cluster = {"id": node.properties.cluster_id,"nodes":[]}
                    cluster.nodes.push(node);
                    clusterData.clusters.push(cluster)
                }else{
                    //如果存在，则直接向其中的nodes数组push node
                    cluster.nodes.push(node);// cluster={"cluster_id":1, nodes:[]}
                }
            }
            //cluster边
            for(const edge of this.graphData.edges){
                const scid = nodesById[edge.source].properties.cluster_id
                const tcid = nodesById[edge.target].properties.cluster_id
                //若这两个类已经存在边，忽略
                var found = clusterData.clusterEdges.find(cedge => cedge.source==("c"+scid) && cedge.target==("c"+tcid) )
                //若这两个类不存在边，建立
                if(!found){
                    clusterData.clusterEdges.push({"source":"c"+scid,"target":"c"+tcid,count:1});
                    console.log("建立类之间的边","source",scid,"target",tcid)
                }else{ //已存在，则让count+1
                    found.count+=1;
                }
            }
            console.log("最终的clusterData：",clusterData)
            return clusterData
        },
        show(){
            var containerId = "group-container"
            // 实际开发中把 window.AntVUtil 换成从 @antv/util 引入的相关模块
            // replace window.AntVUtil.isObject with
            // import { isNumber, isArray } from '@antv/util';
            //TODO: #363b40为黑色背景色
            insertCss(`
            .g6-component-contextmenu {
                position: absolute;
                z-index: 2;
                list-style-type: none;
                background-color: #363b40; 
                border-radius: 6px;
                font-size: 14px;
                color: hsla(0,0%,100%,.85);
                width: fit-content;
                transition: opacity .2s;
                text-align: center;
                padding: 0px 20px 0px 20px;
                    box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.6);
                    border: 0px;
            }
            .g6-component-contextmenu ul {
                    padding-left: 0px;
                    margin: 0;
            }
            .g6-component-contextmenu li {
                cursor: pointer;
                list-style-type: none;
                list-style: none;
                margin-left: 0;
                line-height: 38px;
            }
            .g6-component-contextmenu li:hover {
                color: #aaaaaa;
                }

                .g6-toolbar-ul {
                    position: absolute;
                    top: 70px;
                    border: 1px solid #e2e2e2;
                    border-radius: 4px;
                    font-size: 12px;
                    color: #545454;
                    background-color: rgba(255, 255, 255, 0.9);
                    padding: 10px 8px;
                    box-shadow: rgb(174, 174, 174) 0px 0px 10px;
                    width: 100px;
                    cursor: pointer;
                }
            `);

            const { labelPropagation, louvain, findShortestPath } = G6.Algorithm;
            const { uniqueId } = G6.Util;

            const NODESIZEMAPPING = 'degree';
            const SMALLGRAPHLABELMAXLENGTH = 5;
            let labelMaxLength = SMALLGRAPHLABELMAXLENGTH;
            const DEFAULTNODESIZE = 20;
            const DEFAULTAGGREGATEDNODESIZE = 53;
            const NODE_LIMIT = 40; // TODO: 可展示的最大节点数量find a proper number for maximum node number on the canvas
            //////////////////////////////////////////////////////////
            const canvasBackgroundColor = '#363b40';
            const darkBackColor = 'rgb(43, 47, 51)'; //TODO:这里修改节点的背景颜色 原本rgb(43, 47, 51)
            const disableColor = '#777';
            const theme = 'dark'; //原本为dark  可选：dark、default
            const subjectColors = [
            '#5F95FF', // blue
            '#61DDAA',
            '#65789B',
            '#F6BD16',
            '#7262FD',
            '#78D3F8',
            '#9661BC',
            '#F6903D',
            '#008685',
            '#F08BB4',
            ];
            const colorSets = G6.Util.getColorSetsBySubjectColors(
                subjectColors,
                darkBackColor,
                theme,
                disableColor,
            );
            /////////////////////////////////////////////////////
            let graph = null;
            let currentUnproccessedData = { nodes: [], edges: [] };
            let nodeMap = {};
            let aggregatedNodeMap = {};
            let hiddenItemIds = []; // 隐藏的元素 id 数组
            let largeGraphMode = true;
            let cachePositions = {};
            let manipulatePosition = undefined;
            let descreteNodeCenter;
            let layout = {
                type: '',
                instance: null,
                destroyed: true,
            };
            let expandArray = [];
            let collapseArray = [];
            let shiftKeydown = false;
            let CANVAS_WIDTH = 800,
            CANVAS_HEIGHT = 800;

            const duration = 2000;
            const animateOpacity = 0.6;
            const animateBackOpacity = 0.1;
            const virtualEdgeOpacity = 0.1;
            const realEdgeOpacity = 0.2;

            const global = {
                node: {
                    style: {
                        fill: '#2B384E',
                    },
                    labelCfg: {
                        style: {
                            fill: '#acaeaf',
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            fill: '#2B384E',
                        },
                    },
                },
                edge: {
                    style: {
                        stroke: '#acaeaf',
                        realEdgeStroke: '#acaeaf', //'#f00',
                        realEdgeOpacity,
                        strokeOpacity: realEdgeOpacity,
                    },
                    labelCfg: {
                        style: {
                            fill: '#acaeaf',
                            realEdgeStroke: '#acaeaf', //'#f00',
                            realEdgeOpacity: 0.5,
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            stroke: '#fff', // '#3C9AE8',
                        },
                    },
                },
            };
            // Custom super node
            G6.registerNode(
            'aggregated-node',
            {
                draw(cfg, group) {
                let width = 53,
                    height = 27;
                const style = cfg.style || {};
                const colorSet = cfg.colorSet || colorSets[0];

                // halo for hover
                group.addShape('rect', {
                    attrs: {
                    x: -width * 0.55,
                    y: -height * 0.6,
                    width: width * 1.1,
                    height: height * 1.2,
                    fill: colorSet.mainFill,
                    opacity: 0.9,
                    lineWidth: 0,
                    radius: (height / 2 || 13) * 1.2,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'halo-shape',
                    visible: false,
                });

                // focus stroke for hover
                group.addShape('rect', {
                    attrs: {
                    x: -width * 0.55,
                    y: -height * 0.6,
                    width: width * 1.1,
                    height: height * 1.2,
                    fill: colorSet.mainFill, // '#3B4043',
                    stroke: '#AAB7C4',
                    lineWidth: 1,
                    lineOpacty: 0.85,
                    radius: (height / 2 || 13) * 1.2,
                    },
                    name: 'stroke-shape',
                    visible: false,
                });

                const keyShape = group.addShape('rect', {
                    attrs: {
                    ...style,
                    x: -width / 2,
                    y: -height / 2,
                    width,
                    height,
                    fill: colorSet.mainFill, // || '#3B4043',
                    stroke: colorSet.mainStroke,
                    lineWidth: 2,
                    cursor: 'pointer',
                    radius: height / 2 || 13,
                    lineDash: [2, 2],
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'aggregated-node-keyShape',
                });

                let labelStyle = {};
                if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                }
                group.addShape('text', {
                    attrs: {
                        text: `${cfg.count}`,
                        x: 0,
                        y: 0,
                        textAlign: 'center',
                        textBaseline: 'middle',
                        cursor: 'pointer',
                        fontSize: 12,
                        fill: '#fff',
                        opacity: 0.85,
                        fontWeight: 400,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'count-shape',
                    className: 'count-shape',
                    draggable: true,
                });

                // tag for new node
                if (cfg.new) {
                    group.addShape('circle', {
                    attrs: {
                        x: width / 2 - 3,
                        y: -height / 2 + 3,
                        r: 4,
                        fill: '#6DD400',
                        lineWidth: 0.5,
                        stroke: '#FFFFFF',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'typeNode-tag-circle',
                    });
                }
                return keyShape;
                },
                setState: (name, value, item) => {
                const group = item.get('group');
                if (name === 'layoutEnd' && value) {
                    const labelShape = group.find((e) => e.get('name') === 'text-shape');
                    if (labelShape) labelShape.set('visible', true);
                } else if (name === 'hover') {
                    if (item.hasState('focus')) {
                    return;
                    }
                    const halo = group.find((e) => e.get('name') === 'halo-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    halo && halo.show();
                    keyShape.attr('fill', colorSet.activeFill);
                    } else {
                    halo && halo.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                } else if (name === 'focus') {
                    const stroke = group.find((e) => e.get('name') === 'stroke-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    stroke && stroke.show();
                    keyShape.attr('fill', colorSet.selectedFill);
                    } else {
                    stroke && stroke.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                }
                },
                update: undefined,
            },
            'single-node',
            );

            // Custom real node
            G6.registerNode(
            'real-node',
            {
                draw(cfg, group) {
                let r = 30;
                if (isNumber(cfg.size)) {
                    r = cfg.size / 2;
                } else if (isArray(cfg.size)) {
                    r = cfg.size[0] / 2;
                }
                const style = cfg.style || {};
                const colorSet = cfg.colorSet || colorSets[0];

                // halo for hover
                group.addShape('circle', {
                    attrs: {
                    x: 0,
                    y: 0,
                    r: r + 5,
                    fill: style.fill || colorSet.mainFill || '#2B384E',
                    opacity: 0.9,
                    lineWidth: 0,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'halo-shape',
                    visible: false,
                });

                // focus stroke for hover
                group.addShape('circle', {
                    attrs: {
                    x: 0,
                    y: 0,
                    r: r + 5,
                    fill: style.fill || colorSet.mainFill || '#2B384E',
                    stroke: '#fff',
                    strokeOpacity: 0.85,
                    lineWidth: 1,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'stroke-shape',
                    visible: false,
                });

                const keyShape = group.addShape('circle', {
                    attrs: {
                    ...style,
                    x: 0,
                    y: 0,
                    r,
                    fill: colorSet.mainFill,
                    stroke: colorSet.mainStroke,
                    lineWidth: 2,
                    cursor: 'pointer',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'aggregated-node-keyShape',
                });

                let labelStyle = {};
                if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                }

                if (cfg.label) {
                    const text = cfg.label;
                    let labelStyle = {};
                    let refY = 0;
                    if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                    refY += cfg.labelCfg.refY || 0;
                    }
                    let offsetY = 0;
                    const fontSize = labelStyle.fontSize < 8 ? 8 : labelStyle.fontSize;
                    const lineNum = cfg.labelLineNum || 1;
                    offsetY = lineNum * (fontSize || 12);
                    group.addShape('text', {
                    attrs: {
                        text,
                        x: 0,
                        y: r + refY + offsetY + 5,
                        textAlign: 'center',
                        textBaseLine: 'alphabetic',
                        cursor: 'pointer',
                        fontSize,
                        fill: '#fff',
                        opacity: 0.85,
                        fontWeight: 400,
                        stroke: global.edge.labelCfg.style.stroke,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'text-shape',
                    className: 'text-shape',
                    });
                }

                // tag for new node
                if (cfg.new) {
                    group.addShape('circle', {
                    attrs: {
                        x: r - 3,
                        y: -r + 3,
                        r: 4,
                        fill: '#6DD400',
                        lineWidth: 0.5,
                        stroke: '#FFFFFF',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'typeNode-tag-circle',
                    });
                }

                return keyShape;
                },
                setState: (name, value, item) => {
                const group = item.get('group');
                if (name === 'layoutEnd' && value) {
                    const labelShape = group.find((e) => e.get('name') === 'text-shape');
                    if (labelShape) labelShape.set('visible', true);
                } else if (name === 'hover') {
                    if (item.hasState('focus')) {
                    return;
                    }
                    const halo = group.find((e) => e.get('name') === 'halo-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    halo && halo.show();
                    keyShape.attr('fill', colorSet.activeFill);
                    } else {
                    halo && halo.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                } else if (name === 'focus') {
                    const stroke = group.find((e) => e.get('name') === 'stroke-shape');
                    const label = group.find((e) => e.get('name') === 'text-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    stroke && stroke.show();
                    keyShape.attr('fill', colorSet.selectedFill);
                    label && label.attr('fontWeight', 800);
                    } else {
                    stroke && stroke.hide();
                    keyShape.attr('fill', colorSet.mainFill); // '#2B384E'
                    label && label.attr('fontWeight', 400);
                    }
                }
                },
                update: undefined,
            },
            'aggregated-node',
            ); // 这样可以继承 aggregated-node 的 setState

            // Custom the quadratic edge for multiple edges between one node pair
            G6.registerEdge(
            'custom-quadratic',
            {
                setState: (name, value, item) => {
                const group = item.get('group');
                const model = item.getModel();
                if (name === 'focus') {
                    const back = group.find((ele) => ele.get('name') === 'back-line');
                    if (back) {
                    back.stopAnimate();
                    back.remove();
                    back.destroy();
                    }
                    const keyShape = group.find((ele) => ele.get('name') === 'edge-shape');
                    const arrow = model.style.endArrow;
                    if (value) {
                    if (keyShape.cfg.animation) {
                        keyShape.stopAnimate(true);
                    }
                    keyShape.attr({
                        strokeOpacity: animateOpacity,
                        opacity: animateOpacity,
                        stroke: '#fff',
                        endArrow: {
                        ...arrow,
                        stroke: '#fff',
                        fill: '#fff',
                        },
                    });
                    if (model.isReal) {
                        const { lineWidth, path, endArrow, stroke } = keyShape.attr();
                        const back = group.addShape('path', {
                        attrs: {
                            lineWidth,
                            path,
                            stroke,
                            endArrow,
                            opacity: animateBackOpacity,
                        },
                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                        name: 'back-line',
                        });
                        back.toBack();
                        const length = keyShape.getTotalLength();
                        keyShape.animate(
                        (ratio) => {
                            // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations
                            const startLen = ratio * length;
                            // Calculate the lineDash
                            const cfg = {
                            lineDash: [startLen, length - startLen],
                            };
                            return cfg;
                        },
                        {
                            repeat: true, // Whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    } else {
                        let index = 0;
                        const lineDash = keyShape.attr('lineDash');
                        const totalLength = lineDash[0] + lineDash[1];
                        keyShape.animate(
                        () => {
                            index++;
                            if (index > totalLength) {
                            index = 0;
                            }
                            const res = {
                            lineDash,
                            lineDashOffset: -index,
                            };
                            // returns the modified configurations here, lineDash and lineDashOffset here
                            return res;
                        },
                        {
                            repeat: true, // whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    }
                    } else {
                    keyShape.stopAnimate();
                    const stroke = '#acaeaf';
                    const opacity = model.isReal ? realEdgeOpacity : virtualEdgeOpacity;
                    keyShape.attr({
                        stroke,
                        strokeOpacity: opacity,
                        opacity,
                        endArrow: {
                        ...arrow,
                        stroke,
                        fill: stroke,
                        },
                    });
                    }
                }
                },
            },
            'quadratic',
            );

            // Custom the line edge for single edge between one node pair
            G6.registerEdge(
            'custom-line',
            {
                setState: (name, value, item) => {
                const group = item.get('group');
                const model = item.getModel();
                if (name === 'focus') {
                    const keyShape = group.find((ele) => ele.get('name') === 'edge-shape');
                    const back = group.find((ele) => ele.get('name') === 'back-line');
                    if (back) {
                    back.stopAnimate();
                    back.remove();
                    back.destroy();
                    }
                    const arrow = model.style.endArrow;
                    if (value) {
                    if (keyShape.cfg.animation) {
                        keyShape.stopAnimate(true);
                    }
                    keyShape.attr({
                        strokeOpacity: animateOpacity,
                        opacity: animateOpacity,
                        stroke: '#fff',
                        endArrow: {
                        ...arrow,
                        stroke: '#fff',
                        fill: '#fff',
                        },
                    });
                    if (model.isReal) {
                        const { path, stroke, lineWidth } = keyShape.attr();
                        const back = group.addShape('path', {
                        attrs: {
                            path,
                            stroke,
                            lineWidth,
                            opacity: animateBackOpacity,
                        },
                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                        name: 'back-line',
                        });
                        back.toBack();
                        const length = keyShape.getTotalLength();
                        keyShape.animate(
                        (ratio) => {
                            // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations
                            const startLen = ratio * length;
                            // Calculate the lineDash
                            const cfg = {
                            lineDash: [startLen, length - startLen],
                            };
                            return cfg;
                        },
                        {
                            repeat: true, // Whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    } else {
                        const lineDash = keyShape.attr('lineDash');
                        const totalLength = lineDash[0] + lineDash[1];
                        let index = 0;
                        keyShape.animate(
                        () => {
                            index++;
                            if (index > totalLength) {
                            index = 0;
                            }
                            const res = {
                            lineDash,
                            lineDashOffset: -index,
                            };
                            // returns the modified configurations here, lineDash and lineDashOffset here
                            return res;
                        },
                        {
                            repeat: true, // whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    }
                    } else {
                    keyShape.stopAnimate();
                    const stroke = '#acaeaf';
                    const opacity = model.isReal ? realEdgeOpacity : virtualEdgeOpacity;
                    keyShape.attr({
                        stroke,
                        strokeOpacity: opacity,
                        opacity: opacity,
                        endArrow: {
                        ...arrow,
                        stroke,
                        fill: stroke,
                        },
                    });
                    }
                }
                },
            },
            'single-edge',
            );

            const descendCompare = (p) => {
                // 这是比较函数
                return function (m, n) {
                    const a = m[p];
                    const b = n[p];
                    return b - a; // 降序
                };
            };

            const clearFocusItemState = (graph) => {
                if (!graph) return;
                clearFocusNodeState(graph);
                clearFocusEdgeState(graph);
            };

            // 清除图上所有节点的 focus 状态及相应样式
            const clearFocusNodeState = (graph) => {
                const focusNodes = graph.findAllByState('node', 'focus');
                focusNodes.forEach((fnode) => {
                    graph.setItemState(fnode, 'focus', false); // false
                });
            };

            // 清除图上所有边的 focus 状态及相应样式
            const clearFocusEdgeState = (graph) => {
                const focusEdges = graph.findAllByState('edge', 'focus');
                focusEdges.forEach((fedge) => {
                    graph.setItemState(fedge, 'focus', false);
                });
            };

            // 截断长文本。length 为文本截断后长度，elipsis 是后缀
            const formatText = (text, length = 5, elipsis = '...') => {
                if (!text) return '';
                if (text.length > length) {
                    return `${text.substr(0, length)}${elipsis}`;
                }
                return text;
            };

            const labelFormatter = (text, minLength = 10) => {
                if (text && text.split('').length > minLength) return `${text.substr(0, minLength)}...`;
                return text;
            };

            const processNodesEdges = (
                nodes,
                edges,
                width,
                height,
                largeGraphMode,
                edgeLabelVisible,
                isNewGraph = false,
            ) => {
                if (!nodes || nodes.length === 0) return {};
                const currentNodeMap = {};
                let maxNodeCount = -Infinity;
                const paddingRatio = 0.3;
                const paddingLeft = paddingRatio * width;
                const paddingTop = paddingRatio * height;
                nodes.forEach((node) => {
                    node.type = node.level === 0 ? 'real-node' : 'aggregated-node';
                    node.isReal = node.level === 0 ? true : false;
                    // node.label = `${node.id}`;
                    if(node.level===0){
                        //node.label = node.properties.name  //以域名作为节点的显示名称
                        node.label = node.properties.Website_title //以网站名称作为显示名称
                    }else{
                        node.label = node.id;
                    }
                    // node.label = node.properties.name || node.id;
                    node.labelLineNum = undefined;
                    node.oriLabel = node.label;
                    node.label = formatText(node.label, labelMaxLength, '...');
                    node.degree = 0;
                    node.inDegree = 0;
                    node.outDegree = 0;
                    if (currentNodeMap[node.id]) {
                        console.warn('node exists already!', node.id);
                        node.id = `${node.id}${Math.random()}`;
                    }
                    currentNodeMap[node.id] = node;
                    if (node.count > maxNodeCount) maxNodeCount = node.count;
                    const cachePosition = cachePositions ? cachePositions[node.id] : undefined;
                    if (cachePosition) {
                        node.x = cachePosition.x;
                        node.y = cachePosition.y;
                        node.new = false;
                    } else {
                        node.new = isNewGraph ? false : true;
                    if (manipulatePosition && !node.x && !node.y) {
                        node.x = manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);
                        node.y = manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);
                    }   
                    }
                });

                let maxCount = -Infinity;
                let minCount = Infinity;
                // let maxCount = 0;
                edges.forEach((edge) => {
                    // to avoid the dulplicated id to nodes
                    if (!edge.id) edge.id = uniqueId('edge');
                    else if (edge.id.split('-')[0] !== 'edge') edge.id = `edge-${edge.id}`;
                    // TODO: delete the following line after the queried data is correct
                    if (!currentNodeMap[edge.source] || !currentNodeMap[edge.target]) {
                    console.warn('edge source target does not exist', edge.source, edge.target, edge.id);
                    return;
                    }
                    const sourceNode = currentNodeMap[edge.source];
                    const targetNode = currentNodeMap[edge.target];

                    if (!sourceNode || !targetNode)
                    console.warn('source or target is not defined!!!', edge, sourceNode, targetNode);

                    // calculate the degree
                    sourceNode.degree++;
                    targetNode.degree++;
                    sourceNode.outDegree++;
                    targetNode.inDegree++;

                    if (edge.count > maxCount) maxCount = edge.count;
                    if (edge.count < minCount) minCount = edge.count;
                });

                nodes.sort(descendCompare(NODESIZEMAPPING));
                const maxDegree = nodes[0].degree || 1;

                const descreteNodes = [];
                nodes.forEach((node, i) => {
                    // assign the size mapping to the outDegree
                    const countRatio = node.count / maxNodeCount;
                    const isRealNode = node.level === 0;
                    node.size = isRealNode ? DEFAULTNODESIZE : DEFAULTAGGREGATEDNODESIZE;
                    node.isReal = isRealNode;
                    node.labelCfg = {
                        position: 'bottom',
                        offset: 5,
                        style: {
                            fill: global.node.labelCfg.style.fill,
                            fontSize: 6 + countRatio * 6 || 12,
                            stroke: global.node.labelCfg.style.stroke,
                            lineWidth: 3,
                        },
                    };

                    if (!node.degree) {
                    descreteNodes.push(node);
                    }
                });

                const countRange = maxCount - minCount;
                const minEdgeSize = 1;
                const maxEdgeSize = 7;
                const edgeSizeRange = maxEdgeSize - minEdgeSize;
                edges.forEach((edge) => {
                    // set edges' style
                    const targetNode = currentNodeMap[edge.target];

                    const size = ((edge.count - minCount) / countRange) * edgeSizeRange + minEdgeSize || 1;
                    edge.size = size;

                    const arrowWidth = Math.max(size / 2 + 2, 3);
                    const arrowLength = 10;
                    const arrowBeging = targetNode.size + arrowLength;
                    let arrowPath = `M ${arrowBeging},0 L ${arrowBeging + arrowLength},-${arrowWidth} L ${arrowBeging + arrowLength
                    },${arrowWidth} Z`;
                    let d = targetNode.size / 2 + arrowLength;
                    if (edge.source === edge.target) {
                        edge.type = 'loop';
                        arrowPath = undefined;
                    }
                    const sourceNode = currentNodeMap[edge.source];
                    const isRealEdge = targetNode.isReal && sourceNode.isReal;
                    edge.isReal = isRealEdge;
                    const stroke = isRealEdge ? global.edge.style.realEdgeStroke : global.edge.style.stroke;
                    const opacity = isRealEdge
                    ? global.edge.style.realEdgeOpacity
                    : global.edge.style.strokeOpacity;
                    const dash = Math.max(size, 2);
                    const lineDash = isRealEdge ? undefined : [dash, dash];
                    //TODO:边样式
                    edge.style = { 
                        stroke,
                        strokeOpacity: opacity,
                        cursor: 'pointer',
                        lineAppendWidth: Math.max(edge.size || 5, 5),
                        fillOpacity: 1,
                        lineDash,
                        endArrow: arrowPath
                            ? {
                            path: arrowPath,
                            d,
                            fill: stroke,
                            strokeOpacity: 0,
                            }
                            : false,
                    };
                    edge.labelCfg = {
                        autoRotate: true,
                        style: {
                            stroke: global.edge.labelCfg.style.stroke, //边的label的样式
                            fill: global.edge.labelCfg.style.fill,
                            lineWidth: 4,
                            fontSize: 12,
                            lineAppendWidth: 10,
                            opacity: 1,
                        },
                    };
                    if (!edge.oriLabel) edge.oriLabel = edge.label;
                    if (largeGraphMode || !edgeLabelVisible) edge.label = '';
                    else {
                    edge.label = labelFormatter(edge.label, labelMaxLength);
                    }

                    // arrange the other nodes around the hub
                    const sourceDis = sourceNode.size / 2 + 20;
                    const targetDis = targetNode.size / 2 + 20;
                    if (sourceNode.x && !targetNode.x) {
                    targetNode.x = sourceNode.x + sourceDis * Math.cos(Math.random() * Math.PI * 2);
                    }
                    if (sourceNode.y && !targetNode.y) {
                    targetNode.y = sourceNode.y + sourceDis * Math.sin(Math.random() * Math.PI * 2);
                    }
                    if (targetNode.x && !sourceNode.x) {
                    sourceNode.x = targetNode.x + targetDis * Math.cos(Math.random() * Math.PI * 2);
                    }
                    if (targetNode.y && !sourceNode.y) {
                    sourceNode.y = targetNode.y + targetDis * Math.sin(Math.random() * Math.PI * 2);
                    }

                    if (!sourceNode.x && !sourceNode.y && manipulatePosition) {
                    sourceNode.x = manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);
                    sourceNode.y = manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);
                    }
                    if (!targetNode.x && !targetNode.y && manipulatePosition) {
                    targetNode.x = manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);
                    targetNode.y = manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);
                    }
                });

                descreteNodeCenter = {
                    x: width - paddingLeft,
                    y: height - paddingTop,
                };
                descreteNodes.forEach((node) => {
                    if (!node.x && !node.y) {
                    node.x = descreteNodeCenter.x + 30 * Math.cos(Math.random() * Math.PI * 2);
                    node.y = descreteNodeCenter.y + 30 * Math.sin(Math.random() * Math.PI * 2);
                    }
                });

                G6.Util.processParallelEdges(edges, 12.5, 'custom-quadratic', 'custom-line');
                return {
                    maxDegree,
                    edges,
                };
            };

            const getForceLayoutConfig = (graph, largeGraphMode, configSettings) => {
                let {
                    linkDistance,
                    edgeStrength,
                    nodeStrength,
                    nodeSpacing,
                    preventOverlap,
                    nodeSize,
                    collideStrength,
                    alpha,
                    alphaDecay,
                    alphaMin,
                } = configSettings || { preventOverlap: true };

                if (!linkDistance && linkDistance !== 0) linkDistance = 225;
                if (!edgeStrength && edgeStrength !== 0) edgeStrength = 50;
                if (!nodeStrength && nodeStrength !== 0) nodeStrength = 200;
                if (!nodeSpacing && nodeSpacing !== 0) nodeSpacing = 5;

                const config = {
                    type: 'gForce',
                    minMovement: 0.01,
                    maxIteration: 5000,
                    preventOverlap,
                    damping: 0.99,
                    linkDistance: (d) => {
                        // console.log('nodemap',nodeMap)
                        // console.log('aggregatedNodeMap',aggregatedNodeMap)
                        // console.log(d.source,d.target) //c3 c3
                        let dist = linkDistance;
                        const sourceNode = nodeMap[d.source] || aggregatedNodeMap[d.source];
                        const targetNode = nodeMap[d.target] || aggregatedNodeMap[d.target];
                        // console.log(sourceNode,targetNode)
                        // // 两端都是聚合点
                        // if (sourceNode.level && targetNode.level) dist = linkDistance * 3;
                        // // 一端是聚合点，一端是真实节点
                        // else if (sourceNode.level || targetNode.level) dist = linkDistance * 1.5;
                        
                        if (!sourceNode.level && !targetNode.level) dist = linkDistance * 0.3;
                        return dist;
                    },
                    edgeStrength: (d) => {
                        const sourceNode = nodeMap[d.source] || aggregatedNodeMap[d.source];
                        const targetNode = nodeMap[d.target] || aggregatedNodeMap[d.target];
                        // 聚合节点之间的引力小
                        if (sourceNode.level && targetNode.level) return edgeStrength / 2;
                        // 聚合节点与真实节点之间引力大
                        if (sourceNode.level || targetNode.level) return edgeStrength;
                        return edgeStrength;
                    },
                    nodeStrength: (d) => {
                        // 给离散点引力，让它们聚集
                        if (d.degree === 0) return -10;
                        // 聚合点的斥力大
                        if (d.level) return nodeStrength * 2;
                        return nodeStrength;
                    },
                    nodeSize: (d) => {
                        if (!nodeSize && d.size) return d.size;
                        return 50;
                    },
                    nodeSpacing: (d) => {
                        if (d.degree === 0) return nodeSpacing * 2;
                        if (d.level) return nodeSpacing;
                        return nodeSpacing;
                    },
                    onLayoutEnd: () => {
                    if (largeGraphMode) {
                        graph.getEdges().forEach((edge) => {
                        if (!edge.oriLabel) return;
                        edge.update({
                            label: labelFormatter(edge.oriLabel, labelMaxLength),
                        });
                        });
                    }
                    },
                    tick: () => {
                    graph.refreshPositions();
                    },
                };

                if (nodeSize) config['nodeSize'] = nodeSize;
                if (collideStrength) config['collideStrength'] = collideStrength;
                if (alpha) config['alpha'] = alpha;
                if (alphaDecay) config['alphaDecay'] = alphaDecay;
                if (alphaMin) config['alphaMin'] = alphaMin;

                return config;
            };

            const hideItems = (graph) => {
                hiddenItemIds.forEach((id) => {
                    graph.hideItem(id);
                });
            };

            const showItems = (graph) => {
                graph.getNodes().forEach((node) => {
                    if (!node.isVisible()) graph.showItem(node);
                });
                graph.getEdges().forEach((edge) => {
                    if (!edge.isVisible()) edge.showItem(edge);
                });
                hiddenItemIds = [];
            };

            const handleRefreshGraph = (
                graph,
                graphData,
                width,
                height,
                largeGraphMode,
                edgeLabelVisible,
                isNewGraph,
            ) => {
                if (!graphData || !graph) return;
                clearFocusItemState(graph);
                // reset the filtering
                graph.getNodes().forEach((node) => {
                    if (!node.isVisible()) node.show();
                });
                graph.getEdges().forEach((edge) => {
                    if (!edge.isVisible()) edge.show();
                });

                let nodes = [],
                    edges = [];

                nodes = graphData.nodes;
                const processRes = processNodesEdges(
                    nodes,
                    graphData.edges || [],
                    width,
                    height,
                    largeGraphMode,
                    edgeLabelVisible,
                    isNewGraph,
                );

                edges = processRes.edges;

                graph.changeData({ nodes, edges });

                hideItems(graph);
                graph.getNodes().forEach((node) => {
                    node.toFront();
                });

                // layout.instance.stop();
                // force 需要使用不同 id 的对象才能进行全新的布局，否则会使用原来的引用。因此复制一份节点和边作为 force 的布局数据
                layout.instance.init({
                    nodes: graphData.nodes,
                    edges,
                });

                layout.instance.minMovement = 0.0001;
                // layout.instance.getCenter = d => {
                // 	const cachePosition = cachePositions[d.id];
                // 	if (!cachePosition && (d.x || d.y)) return [d.x, d.y, 10];
                // 	else if (cachePosition) return [cachePosition.x, cachePosition.y, 10];
                // 	return [width / 2, height / 2, 10];
                // }
                layout.instance.getMass = (d) => {
                    const cachePosition = cachePositions[d.id];
                    if (cachePosition) return 5;
                    return 1;
                };
                layout.instance.execute();
                return { nodes, edges };
            };

            const getMixedGraph = (
                aggregatedData,
                originData,
                nodeMap,
                aggregatedNodeMap,
                expandArray,
                collapseArray,
            ) => {
                let nodes = [],
                    edges = [];

                const expandMap = {},
                    collapseMap = {};
                expandArray.forEach((expandModel) => {
                    expandMap[expandModel.id] = true;
                });
                collapseArray.forEach((collapseModel) => {
                    collapseMap[collapseModel.id] = true;
                });
                console.log("aggregatedNodeMap",aggregatedNodeMap)
                console.log("expandMap",expandMap)
                aggregatedData.clusters.forEach((cluster, i) => {
                    if (expandMap["c"+cluster.id]) { //是待展开的cluster
                        nodes = nodes.concat(cluster.nodes);
                        //TODO: 如何保留原始的类节点？并添加边
                        nodes = nodes.concat(aggregatedNodeMap["c"+cluster.id])
                        aggregatedNodeMap["c"+cluster.id].expanded = true;
                        //// TODO:添加每个节点到聚合节点的边
                        cluster.nodes.forEach(node=>{
                            const vedge = {
                                target: node.id,
                                source: aggregatedNodeMap["c"+cluster.id].id,
                                id: uniqueId('edge'),
                                isReal:false,
                                label: '',
                            };
                            edges.push(vedge)
                        })
                        ////

                    } else {
                        nodes.push(aggregatedNodeMap["c"+cluster.id]);
                        aggregatedNodeMap["c"+cluster.id].expanded = false;
                    }
                });
                console.log("nodes",nodes)
                console.log("edges",edges)
                originData.edges.forEach((edge) => {
                    const isSourceInExpandArray = expandMap[nodeMap[edge.source].clusterId];
                    const isTargetInExpandArray = expandMap[nodeMap[edge.target].clusterId];
                    if (isSourceInExpandArray && isTargetInExpandArray) {
                        edges.push(edge);
                    } else if (isSourceInExpandArray) {
                        const targetClusterId = nodeMap[edge.target].clusterId;
                        const vedge = {
                            source: edge.source,
                            target: targetClusterId,
                            id: uniqueId('edge'),
                            label: '',
                        };
                        edges.push(vedge);
                    } else if (isTargetInExpandArray) {
                        const sourceClusterId = nodeMap[edge.source].clusterId;
                        const vedge = {
                            target: edge.target,
                            source: sourceClusterId,
                            id: uniqueId('edge'),
                            label: '',
                        };
                        edges.push(vedge);
                    }
                });
                aggregatedData.clusterEdges.forEach((edge) => {
                    if (expandMap[edge.source] || expandMap[edge.target]) return;
                    else edges.push(edge);
                });
                return { nodes, edges };
            };

            const getNeighborMixedGraph = (
                centerNodeModel,
                step,
                originData,
                clusteredData,
                currentData,
                nodeMap,
                aggregatedNodeMap,
                maxNeighborNumPerNode = 5,
            ) => {
                // update the manipulate position for center gravity of the new nodes
                manipulatePosition = { x: centerNodeModel.x, y: centerNodeModel.y };

                // the neighborSubGraph does not include the centerNodeModel. the elements are all generated new nodes and edges
                const neighborSubGraph = generateNeighbors(centerNodeModel, step, maxNeighborNumPerNode);
                // update the origin data
                originData.nodes = originData.nodes.concat(neighborSubGraph.nodes);
                originData.edges = originData.edges.concat(neighborSubGraph.edges);
                // update the origin nodeMap
                neighborSubGraph.nodes.forEach((node) => {
                    nodeMap[node.id] = node;
                });
                // update the clusteredData
                const clusterId = centerNodeModel.clusterId;
                clusteredData.clusters.forEach((cluster) => {
                    if (cluster.id !== clusterId) return;
                    cluster.nodes = cluster.nodes.concat(neighborSubGraph.nodes);
                    cluster.sumTot += neighborSubGraph.edges.length;
                });
                // update the count
                aggregatedNodeMap[clusterId].count += neighborSubGraph.nodes.length;

                currentData.nodes = currentData.nodes.concat(neighborSubGraph.nodes);
                currentData.edges = currentData.edges.concat(neighborSubGraph.edges);
                return currentData;
            };

            const generateNeighbors = (centerNodeModel, step, maxNeighborNumPerNode = 5) => {
                if (step <= 0) return undefined;
                let nodes = [],
                    edges = [];
                const clusterId = centerNodeModel.clusterId;
                const centerId = centerNodeModel.id;
                const neighborNum = Math.ceil(Math.random() * maxNeighborNumPerNode);
                for (let i = 0; i < neighborNum; i++) {
                    const neighborNode = {
                    id: uniqueId('node'),
                    clusterId,
                    level: 0,
                    colorSet: centerNodeModel.colorSet,
                    };
                    nodes.push(neighborNode);
                    const dire = Math.random() > 0.5;
                    const source = dire ? centerId : neighborNode.id;
                    const target = dire ? neighborNode.id : centerId;
                    const neighborEdge = {
                    id: uniqueId('edge'),
                    source,
                    target,
                    label: `${source}-${target}`,
                    };
                    edges.push(neighborEdge);
                    const subNeighbors = generateNeighbors(neighborNode, step - 1, maxNeighborNumPerNode);
                    if (subNeighbors) {
                    nodes = nodes.concat(subNeighbors.nodes);
                    edges = edges.concat(subNeighbors.edges);
                    }
                }
                return { nodes, edges };
            };

            const getExtractNodeMixedGraph = (
                extractNodeData,
                originData,
                nodeMap,
                aggregatedNodeMap,
                currentUnproccessedData,
            ) => {
                const extractNodeId = extractNodeData.id;
                // const extractNodeClusterId = extractNodeData.clusterId;
                // push to the current rendering data
                currentUnproccessedData.nodes.push(extractNodeData);
                // update the count of aggregatedNodeMap, when to revert?
                // aggregatedNodeMap[extractNodeClusterId].count --;

                // extract the related edges
                originData.edges.forEach((edge) => {
                    if (edge.source === extractNodeId) {
                    const targetClusterId = nodeMap[edge.target].clusterId;
                    if (!aggregatedNodeMap[targetClusterId].expanded) {
                        // did not expand, create an virtual edge fromt he extract node to the cluster
                        currentUnproccessedData.edges.push({
                        id: uniqueId('edge'),
                        source: extractNodeId,
                        target: targetClusterId,
                        });
                    } else {
                        // if the cluster is already expanded, push the origin edge
                        currentUnproccessedData.edges.push(edge);
                    }
                    } else if (edge.target === extractNodeId) {
                    const sourceClusterId = nodeMap[edge.source].clusterId;
                    if (!aggregatedNodeMap[sourceClusterId].expanded) {
                        // did not expand, create an virtual edge fromt he extract node to the cluster
                        currentUnproccessedData.edges.push({
                        id: uniqueId('edge'),
                        target: extractNodeId,
                        source: sourceClusterId,
                        });
                    } else {
                        // if the cluster is already expanded, push the origin edge
                        currentUnproccessedData.edges.push(edge);
                    }
                    }
                });
                return currentUnproccessedData;
            };

            const examAncestors = (model, expandedArray, length, keepTags) =>   {
                for (let i = 0; i < length; i++) {
                    const expandedNode = expandedArray[i];
                    if (!keepTags[i] && model.parentId === expandedNode.id) {
                    keepTags[i] = true; // 需要被保留
                    examAncestors(expandedNode, expandedArray, length, keepTags);
                    break;
                    }
                }
            };

            const manageExpandCollapseArray = (nodeNumber, model, collapseArray, expandArray) => {
                manipulatePosition = { x: model.x, y: model.y };

                // 维护 expandArray，若当前画布节点数高于上限，移出 expandedArray 中非 model 祖先的节点)
                if (nodeNumber > NODE_LIMIT) {
                    // 若 keepTags[i] 为 true，则 expandedArray 的第 i 个节点需要被保留
                    const keepTags = {};
                    const expandLen = expandArray.length;
                    // 检查 X 的所有祖先并标记 keepTags
                    examAncestors(model, expandArray, expandLen, keepTags);
                    // 寻找 expandedArray 中第一个 keepTags 不为 true 的点
                    let shiftNodeIdx = -1;
                    for (let i = 0; i < expandLen; i++) {
                    if (!keepTags[i]) {
                        shiftNodeIdx = i;
                        break;
                    }
                    }
                    // 如果有符合条件的节点，将其从 expandedArray 中移除
                    if (shiftNodeIdx !== -1) {
                    let foundNode = expandArray[shiftNodeIdx];
                    if (foundNode.level === 2) {
                        let foundLevel1 = false;
                        // 找到 expandedArray 中 parentId = foundNode.id 且 level = 1 的第一个节点
                        for (let i = 0; i < expandLen; i++) {
                        const eNode = expandArray[i];
                        if (eNode.parentId === foundNode.id && eNode.level === 1) {
                            foundLevel1 = true;
                            foundNode = eNode;
                            expandArray.splice(i, 1);
                            break;
                        }
                        }
                        // 若未找到，则 foundNode 不变, 直接删去 foundNode
                        if (!foundLevel1) expandArray.splice(shiftNodeIdx, 1);
                    } else {
                        // 直接删去 foundNode
                        expandArray.splice(shiftNodeIdx, 1);
                    }
                    // const removedNode = expandedArray.splice(shiftNodeIdx, 1); // splice returns an array
                    const idSplits = foundNode.id.split('-');
                    let collapseNodeId;
                    // 去掉最后一个后缀
                    for (let i = 0; i < idSplits.length - 1; i++) {
                        const str = idSplits[i];
                        if (collapseNodeId) collapseNodeId = `${collapseNodeId}-${str}`;
                        else collapseNodeId = str;
                    }
                    const collapseNode = {
                        id: collapseNodeId,
                        parentId: foundNode.id,
                        level: foundNode.level - 1,
                    };
                    collapseArray.push(collapseNode); //TODO:如何不隐藏父节点？、
                    console.log("collapseArray",collapseArray)
                    }
                }

                const currentNode = {
                    id: model.id,
                    level: model.level,
                    parentId: model.parentId,
                };

                // 加入当前需要展开的节点
                expandArray.push(currentNode);
                console.log("展开节点组",expandArray)
                graph.get('canvas').setCursor('default');
                return { expandArray, collapseArray };
            };

            const cacheNodePositions = (nodes) => {
                const positionMap = {};
                const nodeLength = nodes.length;
                for (let i = 0; i < nodeLength; i++) {
                    const node = nodes[i].getModel();
                    positionMap[node.id] = {
                    x: node.x,
                    y: node.y,
                    level: node.level,
                    };
                }
                return positionMap;
            };

            const stopLayout = () => {
                layout.instance.stop();
            };

            const bindListener = (graph) => {
                graph.on('keydown', (evt) => {
                    const code = evt.key;
                    if (!code) {
                    return;
                    }
                    if (code.toLowerCase() === 'shift') {
                    shiftKeydown = true;
                    } else {
                    shiftKeydown = false;
                    }
                });
                graph.on('keyup', (evt) => {
                    const code = evt.key;
                    if (!code) {
                    return;
                    }
                    if (code.toLowerCase() === 'shift') {
                    shiftKeydown = false;
                    }
                });
                graph.on('node:mouseenter', (evt) => {
                    const { item } = evt;
                    const model = item.getModel();
                    const currentLabel = model.label;
                    model.oriFontSize = model.labelCfg.style.fontSize;
                    item.update({
                    label: model.oriLabel,
                    });
                    model.oriLabel = currentLabel;
                    graph.setItemState(item, 'hover', true);
                    item.toFront();
                });

                graph.on('node:mouseleave', (evt) => {
                    const { item } = evt;
                    const model = item.getModel();
                    const currentLabel = model.label;
                    item.update({
                    label: model.oriLabel,
                    });
                    model.oriLabel = currentLabel;
                    graph.setItemState(item, 'hover', false);
                });

                graph.on('edge:mouseenter', (evt) => {
                    const { item } = evt;
                    const model = item.getModel();
                    const currentLabel = model.label;
                    item.update({
                    label: model.oriLabel,
                    });
                    model.oriLabel = currentLabel;
                    item.toFront();
                    item.getSource().toFront();
                    item.getTarget().toFront();
                });

                graph.on('edge:mouseleave', (evt) => {
                    const { item } = evt;
                    const model = item.getModel();
                    const currentLabel = model.label;
                    item.update({
                    label: model.oriLabel,
                    });
                    model.oriLabel = currentLabel;
                });
                // click node to show the detail drawer
                graph.on('node:click', (evt) => {
                    stopLayout();
                    if (!shiftKeydown) clearFocusItemState(graph);
                    else clearFocusEdgeState(graph);
                    const { item } = evt;

                    // highlight the clicked node, it is down by click-select
                    graph.setItemState(item, 'focus', true);

                    if (!shiftKeydown) {
                    // 将相关边也高亮
                    const relatedEdges = item.getEdges();
                    relatedEdges.forEach((edge) => {
                        graph.setItemState(edge, 'focus', true);
                    });
                    }
                });

                // click edge to show the detail of integrated edge drawer
                graph.on('edge:click', (evt) => {
                    stopLayout();
                    if (!shiftKeydown) clearFocusItemState(graph);
                    const { item } = evt;
                    // highlight the clicked edge
                    graph.setItemState(item, 'focus', true);
                });

                // click canvas to cancel all the focus state
                graph.on('canvas:click', (evt) => {
                    clearFocusItemState(graph);
                    console.log(graph.getGroup(), graph.getGroup().getBBox(), graph.getGroup().getCanvasBBox());
                });
            };

            const toolbar = new G6.ToolBar({
                // container: tc,
                className: 'g6-toolbar-ul',
                getContent: () => {
                    return `
                    <ul>
                        <li code='search'><i class='el-icon-search'></i></li>
                        <li code='undo'>撤销</li>
                        <li code='redo'>回退</li>
                    </ul>
                    `;
                },
                handleClick: (code, graph) => {
                    if (code === 'add') {
                    graph.addItem('node', {
                        id: 'node2',
                        label: 'node2',
                        x: 300,
                        y: 150,
                    });
                    } else if (code === 'undo') {
                    toolbar.undo();
                    } else if (code === 'redo') {
                    toolbar.redo();
                    }
                },
            });


            //TODO: https://gw.alipayobjects.com/os/antvdemo/assets/data/relations.json
            //api/graph/all
            // fetch('https://gw.alipayobjects.com/os/antvdemo/assets/data/relations.json')
            fetch('api/graph/websites?limit='+'&wname=')
            .then((res) => res.json())
            .then((data) => {
                const container = document.getElementById(containerId);
                container.style.backgroundColor = canvasBackgroundColor; //TODO:背景颜色?
                CANVAS_WIDTH = container.scrollWidth;
                CANVAS_HEIGHT = (container.scrollHeight || 480) - 30;

                nodeMap = {};
                // const clusteredData = louvain(data, false, 'weight');
                console.log(data)
                this.graphData=data;
                const clusteredData = this.showmy()

                console.log('cluster data loucain',clusteredData)
                
                const aggregatedData = { nodes: [], edges: [] };
                clusteredData.clusters.forEach((cluster, i) => {
                    cluster.nodes.forEach((node) => {
                        node.level = 0;
                        //node.label = node.properties.name; //TODO:修改
                        node.type = '';
                        node.colorSet = colorSets[i];
                        nodeMap[node.id] = node;
                    });
                    const cnode = {
                        id: "c"+cluster.id,
                        // id: cluster.id,
                        type: 'aggregated-node',
                        count: cluster.nodes.length,
                        level: 1,
                        label: cluster.id,
                        colorSet: colorSets[i],
                        idx: i,
                    };
                    aggregatedNodeMap["c"+cluster.id] = cnode;
                    aggregatedData.nodes.push(cnode);
                });
                clusteredData.clusterEdges.forEach((clusterEdge) => {
                    const cedge = {
                        ...clusterEdge,
                        size:Math.log(clusterEdge.count),
                        // size: 1, //TODO:修改 Math.log(clusterEdge.count),
                        label: '',
                        id: uniqueId('edge'),
                    };
                    if (cedge.source === cedge.target) {
                        cedge.type = 'loop';
                        cedge.loopCfg = {
                        dist: 20,
                        };
                    } else cedge.type = 'line';
                    aggregatedData.edges.push(cedge);
                });
                console.log("clusteredData",clusteredData)
                console.log("aggregatedData",aggregatedData)
                // console.log("nodemap",nodeMap)
                data.edges.forEach((edge) => {
                    edge.label = `${edge.source}-${edge.target}`;
                    edge.id = uniqueId('edge');
                });

                currentUnproccessedData = aggregatedData;

                const { edges: processedEdges } = processNodesEdges(
                    currentUnproccessedData.nodes,
                    currentUnproccessedData.edges,
                    CANVAS_WIDTH,
                    CANVAS_HEIGHT,
                    largeGraphMode,
                    true,
                    true,
                );

                //TODO:上下文菜单
                const contextMenu = new G6.Menu({
                    shouldBegin(evt) {
                        if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) return true;
                        if (evt.item) return true;
                        return false;
                    },
                    getContent(evt) {
                        const { item } = evt;
                        if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) {
                        return `<ul>
                        <li id='show'>Show all Hidden Items</li>
                        <li id='collapseAll'>Collapse all Clusters</li>
                        </ul>`;
                        } else if (!item) return;
                        const itemType = item.getType();
                        const model = item.getModel();
                        if (itemType && model) {
                        if (itemType === 'node') {
                            if (model.level !== 0) {
                                console.log(model)
                                if(model.expanded==true){
                                    return `<ul>
                                        <li id='detail'>查看团伙详情</li>
                                        </ul>`;
                                } 
                            return `<ul>
                                <li id='expand'>展开团伙聚类</li>
                                <li id='detail'>查看团伙详情</li>
                                <li id='hide'>隐藏团伙</li>
                                </ul>`;
                            } 
                            else {
                                return `<ul>
                                <li id='collapse'>折叠团伙信息</li>
                                <li id='neighbor-1'>Find 1-degree Neighbors</li>
                                </ul>`;
                            }
                        } else {
                            return `<ul>
                            <li id='hide'>隐藏边</li>
                        </ul>`;
                        }
                        }
                    },
                    handleMenuClick: (target, item) => {
                        const model = item && item.getModel();
                        const liIdStrs = target.id.split('-');
                        let mixedGraphData;
                        switch (liIdStrs[0]) {
                        case 'hide':
                            graph.hideItem(item);
                            hiddenItemIds.push(model.id);
                            break;
                        case 'expand':
                            const newArray = manageExpandCollapseArray(
                                graph.getNodes().length,
                                model,
                                collapseArray,
                                expandArray,
                            );
                            expandArray = newArray.expandArray;
                            collapseArray = newArray.collapseArray;
                            mixedGraphData = getMixedGraph(
                                clusteredData,
                                data,
                                nodeMap,
                                aggregatedNodeMap,
                                expandArray,
                                collapseArray,
                            );
                            break;
                        case 'collapse':
                            const aggregatedNode = aggregatedNodeMap[model.clusterId];
                            manipulatePosition = { x: aggregatedNode.x, y: aggregatedNode.y };
                            collapseArray.push(aggregatedNode);
                            for (let i = 0; i < expandArray.length; i++) {
                            if (expandArray[i].id === model.clusterId) {
                                expandArray.splice(i, 1);
                                break;
                            }
                            }
                            mixedGraphData = getMixedGraph(
                                clusteredData,
                                data,
                                nodeMap,
                                aggregatedNodeMap,
                                expandArray,
                                collapseArray,
                            );
                            break;
                        case 'collapseAll':
                            expandArray = [];
                            collapseArray = [];
                            mixedGraphData = getMixedGraph(
                            clusteredData,
                            data,
                            nodeMap,
                            aggregatedNodeMap,
                            expandArray,
                            collapseArray,
                            );
                            break;
                        case 'neighbor':
                            const expandNeighborSteps = parseInt(liIdStrs[1]);
                            mixedGraphData = getNeighborMixedGraph(
                                model,
                                expandNeighborSteps,
                                data,
                                clusteredData,
                                currentUnproccessedData,
                                nodeMap,
                                aggregatedNodeMap,
                                10,
                            );
                            break;
                        case 'show':
                            showItems(graph);
                            break;
                        case 'detail':
                            // this.$router.push('/analyse/index')
                            const cid = model.id.substring(1)
                            console.log("查看团伙",cid)
                            this.$router.push({path:"/trace/analyse",query: {id: cid}})
                            break;
                        default:
                            break;
                        }
                        if (mixedGraphData) {
                            cachePositions = cacheNodePositions(graph.getNodes());
                            currentUnproccessedData = mixedGraphData;
                            handleRefreshGraph(
                                graph,
                                currentUnproccessedData,
                                CANVAS_WIDTH,
                                CANVAS_HEIGHT,
                                largeGraphMode,
                                true,
                                false,
                            );
                        }
                    },
                    // offsetX and offsetY include the padding of the parent container
                    // 需要加上父级容器的 padding-left 16 与自身偏移量 10
                    offsetX: 16 + 10,
                    // 需要加上父级容器的 padding-top 24 、画布兄弟元素高度、与自身偏移量 10
                    offsetY: 0,
                    // the types of items that allow the menu show up
                    // 在哪些类型的元素上响应
                    itemTypes: ['node', 'edge', 'canvas'],
                });

                graph = new G6.Graph({
                    container: containerId,
                    width: CANVAS_WIDTH,
                    height: CANVAS_HEIGHT,
                    linkCenter: true,
                    minZoom: 0.1,
                    groupByTypes: false,
                    modes: {
                        default: [
                        {
                            type: 'drag-canvas',
                            enableOptimize: true,
                        },
                        {
                            type: 'zoom-canvas',
                            enableOptimize: true,
                            optimizeZoom: 0.01,
                        },
                        'drag-node',
                        'shortcuts-call',
                        ],
                        lassoSelect: [
                        {
                            type: 'zoom-canvas',
                            enableOptimize: true,
                            optimizeZoom: 0.01,
                        },
                        {
                            type: 'lasso-select',
                            selectedState: 'focus',
                            trigger: 'drag',
                        },
                        ],
                        fisheyeMode: [],
                    },
                    defaultNode: {
                        type: 'aggregated-node',
                        size: DEFAULTNODESIZE,
                    },
                    plugins: [contextMenu],
                });

                graph.get('canvas').set('localRefresh', false);

                const layoutConfig = getForceLayoutConfig(graph, largeGraphMode);
                    layoutConfig.center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];
                    layout.instance = new G6.Layout['gForce'](layoutConfig);
                    layout.instance.init({
                    nodes: currentUnproccessedData.nodes,
                    edges: processedEdges,
                });
                layout.instance.execute();

                bindListener(graph);
                graph.data({ nodes: aggregatedData.nodes, edges: processedEdges });
                graph.render();
            });

            if (typeof window !== 'undefined')
            window.onresize = () => {
                if (!graph || graph.get('destroyed')) return;
                const container = document.getElementById(containerId);
                if (!container) return;
                graph.changeSize(container.scrollWidth, container.scrollHeight - 30);
            };
        },
        showGroupRank(){

            const data1 = [
            {
                type: '家具家电',
                sales: 38,
            },
            {
                type: '粮油副食',
                sales: 52,
            },
            {
                type: '生鲜水果',
                sales: 61,
            },
            {
                type: '美容洗护',
                sales: 145,
            },
            {
                type: '母婴用品',
                sales: 48,
            },
            {
                type: '进口食品',
                sales: 38,
            },
            {
                type: '食品饮料',
                sales: 38,
            },
            {
                type: '家庭清洁',
                sales: 38,
            }
            ];

            const columnPlot = new Column('rank-container', {
                data1,
                xField: 'type',
                yField: 'sales',
                autoFit:true,
                label: {
                    // 可手动配置 label 数据标签位置
                    position: 'middle', // 'top', 'bottom', 'middle',
                    // 配置样式
                    style: {
                    fill: '#FFFFFF',
                    opacity: 0.6,
                    },
                },
                xAxis: {
                    label: {
                    autoHide: true,
                    autoRotate: false,
                    },
                },
                meta: {
                    type: {
                    alias: '类别',
                    },
                    sales: {
                    alias: '销售额',
                    },
                },
            });

            columnPlot.render();
        },
        showBubble(){
            fetch('https://gw.alipayobjects.com/os/antfincdn/t81X1wXdoj/scatter-data.json')
            .then((res) => res.json())
            .then((data) => {
                const scatterPlot = new Scatter('bubble-container', {
                appendPadding: 30,
                data,
                xField: 'x',
                yField: 'y',
                colorField: 'genre',
                color: [
                    'r(0.4, 0.3, 0.7) 0:#939393 1:#5B8FF9',
                ],
                pointStyle: {
                    fillOpacity: 0.8,
                    stroke: '#5B8FF9',
                },
                sizeField: 'size',
                size: [5, 20],
                shape: 'circle',
                yAxis: {
                    nice: true,
                    line: {
                    style: {
                        stroke: '#eee',
                    },
                    },
                },
                xAxis: {
                    grid: {
                    line: {
                        style: {
                        stroke: '#eee',
                        },
                    },
                    },
                    line: {
                    style: {
                        stroke: '#eee',
                    },
                    },
                },
                });
                scatterPlot.render();
            });

        },
        currentPageData(){

        }

    },
    mounted(){
        this.show();
        this.showBubble();
        this.showGroupRank();
        // this.getAllWebsites()
    }
};
</script>

<style scoped>

    .page{
        padding:5px
    }

    /**修改canvas背景颜色   background-color: rgb(245, 234, 253) !important;**/
    .group-container{
        border-radius: 14px;
        height: 566px;
        /**
        height:566px;
        padding: 10px;
        margin: 10px;**/
        
    }
    .group-rank{
        height: 320px;
    }
    .timeline-card{
        height:566px;
    }

    .timeline-container{
        padding: 5px;
        height:510px;
    }

      .ant-timeline-item{
        color: #fff !important;
      }

    /deep/.el-row{
        margin-bottom:5px;
    }
    /deep/.el-statistic .head {
        margin-bottom: 4px;
        color: #b4b4b5;
        font-size: 13px;
    }

    /deep/.el-statistic .con .number {
        font-size: 20px;
        color: #b4b4b5;
        padding: 0 4px;
    }

    /deep/.el-divider {
        background-color: #585858 !important;
    }

    /deep/.el-table th.el-table__cell.is-leaf, .el-table td.el-table__cell {
        border-left: transparent;
    }


      
</style>

