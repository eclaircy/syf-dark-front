<template>
    <div class="page">
        <!-- <router-view /> -->
        <el-row>
            <el-card>
                 <div style="font-size: 20px;margin-bottom: 7px;">团伙全局溯源</div>
                 <span>挖掘恶意下载网站潜在黑灰产团伙，梳理团伙动态变化</span>
            </el-card>
        </el-row>

        <el-row :gutter="5">
            <el-col :span="15">
                <el-card class="group-container" 
                    v-loading="loading"
                    element-loading-text="Loading"
                    element-loading-spinner="el-icon-loading"
                    element-loading-background="#343A40">
                    <el-row :gutter="20">
                        <el-col :span="12">
                          <div style="color:white">
                            <el-statistic group-separator="," decimal-separator="." :value="groupCount" title="团伙总数">
                              <template slot="prefix">
                                <i class="el-icon-s-flag" style="color: red"></i>
                              </template>
                              {{ groupCount }}
                            </el-statistic>
                          </div>
                        </el-col>

                        <el-col :span="12">
                          <div>
                            <el-statistic :value="0" title="今日新增团伙">
                            </el-statistic>
                          </div>
                        </el-col>
                      </el-row>
                      <el-divider></el-divider>
                    <div id="group-container" ></div>
                </el-card>
                
            </el-col>   
            <el-col :span="9">
                <el-card class="timeline-card">
                    <div class="card-title">团伙时间轴</div>
                    <el-scrollbar style="height:510px;" wrap-style="overflow-x:hidden;">
                    <div class="timeline-container" >
                        <a-timeline mode="alternate" style="margin-top:5px;" >
                            <!-- :color="item.color" -->
                            <a-timeline-item v-for="(item,index) in timelineList" :key="index">
                                <div style="font-weight:bold;color:#DADADA;">
                                    团伙 <span  style="font-family:Times New Roman;font-size:15px">{{item.cid}}</span>：新增可疑{{ labelType[item.label] }}
                                    <div style="font-family:Times New Roman;font-size:16px"> {{ item.name }}</div>
                                </div>
                                <div><b  style="font-family:Times New Roman;font-size:16px;color:#DADADA;">{{item.time}}</b></div>
                            </a-timeline-item>
                        </a-timeline>
                    </div>
                    </el-scrollbar>
                </el-card>
            </el-col>
        </el-row>

        <el-row :gutter="5">
            <el-col :span="12">
                <el-card style="height:400px">
                    <div class="card-title">团伙列表</div>
                    <!-- <div id="rank-container" style="height:400px">
                    </div> -->
                    <!-- <el-row>
                        <el-col :span="8">
                            <svg t="1683434934151" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7161" width="60" height="60"><path d="M287.762 124.318v252.871c0 123.331 100.905 224.238 224.238 224.238 123.331 0 224.238-100.907 224.238-224.238V124.318H287.762z" fill="#82A0AF" p-id="7162"></path><path d="M379.487 124.318v149.434c0 72.882 59.63 132.513 132.513 132.513 72.882 0 132.513-59.631 132.513-132.513V124.318H379.487z" fill="#E0EAED" p-id="7163"></path><path d="M644.513 124.318v149.434c0 72.882-59.631 132.514-132.513 132.514-72.884 0-132.514-59.631-132.514-132.514V124.318h265.027m19.201-19.201H360.285v168.635c0 83.656 68.059 151.714 151.715 151.714s151.714-68.059 151.714-151.714V105.117z" fill="#FFFFFF" p-id="7164"></path><path d="M512 622.736m-339.055 0a339.055 339.055 0 1 0 678.11 0 339.055 339.055 0 1 0-678.11 0Z" fill="#9EC2F7" p-id="7165"></path><path d="M512 622.736m-250.074 0a250.074 250.074 0 1 0 500.148 0 250.074 250.074 0 1 0-500.148 0Z" fill="#DDECF7" p-id="7166"></path><path d="M512 372.662c138.112 0 250.074 111.962 250.074 250.074S650.112 872.81 512 872.81c-138.113 0-250.074-111.962-250.074-250.074S373.888 372.662 512 372.662m0-24.001c-151.126 0-274.075 122.95-274.075 274.075S360.874 896.811 512 896.811s274.075-122.95 274.075-274.076S663.126 348.661 512 348.661z" fill="#FFFFFF" p-id="7167"></path><path d="M786.015 124.319h-548.03c-17.08 0-31.055-13.975-31.055-31.055s13.975-31.055 31.055-31.055h548.029c17.08 0 31.055 13.975 31.055 31.055 0.001 17.08-13.974 31.055-31.054 31.055z" fill="#231815" p-id="7168"></path><path d="M623.478 748.689v42.438h-218.7v-34.684l128.12-130.562c13.599-13.599 23.256-25.839 28.97-36.723 5.71-10.875 8.569-22.576 8.569-35.092 0-17.949-5.241-32.233-15.708-42.836-10.477-10.613-24.685-15.915-42.639-15.915-16.594 0-30.465 4.285-41.617 12.849-11.157 8.569-19.177 20.748-24.071 36.517l-37.947-22.435c7.346-22.576 19.993-39.785 37.947-51.616 17.949-11.832 40.394-17.752 67.32-17.752 20.945 0 39.644 4.285 56.102 12.854 16.454 8.569 29.237 20.542 38.355 35.908 9.108 15.371 13.669 32.711 13.669 52.024 0 18.498-4.631 35.43-13.876 50.796-9.249 15.371-24.343 33.803-45.288 55.287l-86.09 88.944h146.884z" p-id="7169"></path></svg>
                             第二
                        </el-col>
                        <el-col :span="8">
                            <svg t="1683434877888" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6052" data-spm-anchor-id="a313x.7781069.0.i0" width="60" height="60"><path d="M287.762 124.318v252.871c0 123.331 100.905 224.238 224.238 224.238 123.331 0 224.238-100.907 224.238-224.238V124.318H287.762z" fill="#D81919" p-id="6053"></path><path d="M379.487 124.318v149.434c0 72.882 59.63 132.513 132.513 132.513 72.882 0 132.513-59.631 132.513-132.513V124.318H379.487z" fill="#FACC60" p-id="6054"></path><path d="M644.513 124.318v149.434c0 72.882-59.631 132.514-132.513 132.514-72.884 0-132.514-59.631-132.514-132.514V124.318h265.027m19.201-19.201H360.285v168.635c0 83.656 68.059 151.714 151.715 151.714s151.714-68.059 151.714-151.714V105.117z" fill="#FFFFFF" p-id="6055"></path><path d="M512 622.736m-339.055 0a339.055 339.055 0 1 0 678.11 0 339.055 339.055 0 1 0-678.11 0Z" fill="#F8B643" p-id="6056"></path><path d="M512 622.736m-250.074 0a250.074 250.074 0 1 0 500.148 0 250.074 250.074 0 1 0-500.148 0Z" fill="#FFF89F" p-id="6057"></path><path d="M512 372.662c138.112 0 250.074 111.962 250.074 250.074S650.112 872.81 512 872.81c-138.113 0-250.074-111.962-250.074-250.074S373.888 372.662 512 372.662m0-24.001c-151.126 0-274.075 122.95-274.075 274.075S360.874 896.811 512 896.811s274.075-122.95 274.075-274.076S663.126 348.661 512 348.661z" fill="#FFFFFF" p-id="6058"></path><path d="M786.015 124.319h-548.03c-17.08 0-31.055-13.975-31.055-31.055s13.975-31.055 31.055-31.055h548.029c17.08 0 31.055 13.975 31.055 31.055 0.001 17.08-13.974 31.055-31.054 31.055z" fill="#231815" p-id="6059"></path><path d="M556.594 800.727h-51.41V527.763l-68.956 39.578 0.408-51.41 82.827-48.147h37.131v332.943z" p-id="6060"></path></svg>
                           
                            第一
                        </el-col>
                        <el-col :span="8">
                            <svg t="1683434958123" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7966" width="60" height="60"><path d="M287.762 124.318v252.871c0 123.331 100.905 224.238 224.238 224.238 123.331 0 224.238-100.907 224.238-224.238V124.318H287.762z" fill="#BF4C19" p-id="7967"></path><path d="M379.487 124.318v149.434c0 72.882 59.63 132.513 132.513 132.513 72.882 0 132.513-59.631 132.513-132.513V124.318H379.487z" fill="#DC8C57" p-id="7968"></path><path d="M644.513 124.318v149.434c0 72.882-59.631 132.514-132.513 132.514-72.884 0-132.514-59.631-132.514-132.514V124.318h265.027m19.201-19.201H360.285v168.635c0 83.656 68.059 151.714 151.715 151.714s151.714-68.059 151.714-151.714V105.117z" fill="#FFFFFF" p-id="7969"></path><path d="M512 622.736m-339.055 0a339.055 339.055 0 1 0 678.11 0 339.055 339.055 0 1 0-678.11 0Z" fill="#FCC181" p-id="7970"></path><path d="M512 622.736m-250.074 0a250.074 250.074 0 1 0 500.148 0 250.074 250.074 0 1 0-500.148 0Z" fill="#FFE6BF" p-id="7971"></path><path d="M512 372.662c138.112 0 250.074 111.962 250.074 250.074S650.112 872.81 512 872.81c-138.113 0-250.074-111.962-250.074-250.074S373.888 372.662 512 372.662m0-24.001c-151.126 0-274.075 122.95-274.075 274.075S360.874 896.811 512 896.811s274.075-122.95 274.075-274.076S663.126 348.661 512 348.661z" fill="#FFFFFF" p-id="7972"></path><path d="M786.015 124.319h-548.03c-17.08 0-31.055-13.975-31.055-31.055s13.975-31.055 31.055-31.055h548.029c17.08 0 31.055 13.975 31.055 31.055 0.001 17.08-13.974 31.055-31.054 31.055z" fill="#231815" p-id="7973"></path><path d="M627.439 699.539c0 20.677-4.692 39.105-14.077 55.287-9.385 16.187-22.51 28.764-39.372 37.741-16.871 8.977-36.18 13.468-57.94 13.468-25.843 0-48.082-5.916-66.711-17.752-18.634-11.832-31.351-28.079-38.148-48.757l37.947-22.44c5.161 14.687 13.463 26.11 24.887 34.272 11.424 8.161 25.431 12.24 42.025 12.24 18.493 0 33.386-5.916 44.678-17.748 11.283-11.832 16.932-27.264 16.932-46.31 0-19.585-5.649-34.947-16.932-46.104-11.293-11.152-26.725-16.73-46.31-16.73-19.857 0-34.68 6.394-44.472 19.177l-28.97-31.417 108.53-113.836H424.654v-42.846h187.691v34.684l-86.91 91.804c19.585 0.272 37.131 4.894 52.633 13.871 15.507 8.977 27.606 21.423 36.316 37.333 8.7 15.914 13.055 33.938 13.055 54.063z" p-id="7974"></path></svg>
                            第三
                        </el-col>
                    </el-row> -->
                    <el-scrollbar style="height:285px;"  wrap-style="overflow-x:hidden;">
                        <el-table :data="clusterCountList" size="small" class="tableBox"  style="width: 100%;" >
                            <el-table-column prop="id" label="排名" type="index" width="70px;">
                                <template slot-scope="scope">
                                    <a-badge :count="scope.$index + 1" :number-style="{ backgroundColor: '#654E92',color: '#fff',boxShadow: '0 0 0 1px #654E92 inset',}" style="margin-right:10px;"/>
                                </template>
                            </el-table-column>
                            
                            <el-table-column prop="count" :show-overflow-tooltip=true label="恶意网站数量"></el-table-column>
                        
                            <el-table-column prop="count" label="团伙规模" :show-overflow-tooltip=true>
                                <template slot-scope="scope">
                                    <el-tag size="mini" disable-transitions>{{scope.row.size}}</el-tag>
                                </template>
                            </el-table-column>
                
                            <el-table-column prop="id" :show-overflow-tooltip=true label="团伙id">
                                <template slot-scope="scope">
                                    <a-badge :count="scope.row.id" :number-style="{ backgroundColor: '#654E92',color: '#fff',boxShadow: '0 0 0 1px #654E92 inset',}" style="margin-right:10px;font-family:Times New Roman;"/>
                                </template>
                            </el-table-column>
                            
                        </el-table>
                    </el-scrollbar>
                    
                </el-card>
                
            </el-col>
            <el-col :span="12">
                <el-card  style="height:400px">
                    <div class="card-title">团伙增长情况</div>
                    <div id="bubble-container" style="height:280px"></div>
                </el-card>
            </el-col>
        </el-row>
        <!-- <div id="bubble-container" style="height:400px"></div> -->

      
    </div>
</template>

<script>

import G6 from '@antv/g6';
import insertCss from 'insert-css';
import { isNumber, isArray } from '@antv/util';
import { Column } from '@antv/g2plot';
import { Scatter } from '@antv/g2plot';
import { objectEntries } from '@vueuse/core';


export default {
    components: {

    },
    data(){
        return{
            loading:true,
            graphData:'',
            cid:'',
            groupCount:'',
            clusterCountList:'',
            timelineList:[],
            subjectColors : [
                '#5F95FF', // blue
                '#61DDAA',
                '#65789B',
                '#F6BD16',
                '#7262FD',
                '#78D3F8',
                '#9661BC',
                '#F6903D',
                '#008685',
                '#F08BB4',
            ],
            labelType: {
                Website: "网站",
                Company: "公司",
                Person: "人员",
                Ip: "IP",
                Downlink: "下载链接",
            },
        }
    },
    methods:{ 
        getAllWebsites(){
            const limit = 300;
            var all='api/graph/websites?limit='+'&wname=';
            var url = "api/graph/clusters"
            this.axios({
                url:url,
                method:'get'
            }).then(res=>{
                // this.$store.commit('setGraphData', res.data)
                this.graphData = res.data;
                return this.showmy()
            })
        },
        showmy(){
            //默认只展示团伙聚类的椭圆，椭圆之间可以有边，最多2条，根据其中包含网站之间的边构建；
            //点开展开聚类之后，展示具体其中网站和其他簇的边，cluster节点不消失，以便将它包含的网站连接起来；但是cluster和其他cluster的边消失了。
            //点击折叠团伙后，恢复初始状态

            //1.首先获取所有的类别数量，创建Cluster节点
            //let nodes = [{"cluster_id":1},{"cluster_id":2},{"cluster_id":3},{"cluster_id":1},{"cluster_id":1},{"cluster_id":2}];
            let clusterCounts = {};
            let clusterCountList = [];
            for (let node of this.graphData.nodes) {
                let clusterId = node.properties.cluster_id;
                if (clusterId in clusterCounts) {
                    clusterCounts[clusterId]++;
                } else {
                    clusterCounts[clusterId] = 1;
                }
            }
            for(var key of Object.keys(clusterCounts)){
                clusterCountList.push({"id":"c"+key,"count":clusterCounts[key]});
            }
            const result = clusterCountList.sort((a, b) => b.count - a.count);
            console.log('clusterCount',result)
            this.clusterCountList=result;
            this.classifyNumbers(this.clusterCountList);
            this.groupCount= Object.keys(clusterCounts).length;
            


            // 1.1 将nodes数组转换为以id为键的JavaScript对象
            let clusterData = [];
            clusterData.clusters=[];
            clusterData.clusterEdges=[];
            const nodesById = {};
            //cluster节点
            for(let node of this.graphData.nodes){
                nodesById[node.id] = node;
                //给每个node添加level=0属性
                node.level=0;
                node.clusterId = "c"+node.properties.cluster_id
                //如果没出现过这个类别，就把这个类别加进去
                var cluster = clusterData.clusters.find(c=>c.id === node.properties.cluster_id);
                if(!cluster){ //若目前不存在此cluster，则创建
                    let cluster = {"id": node.properties.cluster_id,"nodes":[]}
                    cluster.nodes.push(node);
                    clusterData.clusters.push(cluster)
                }else{
                    //如果存在，则直接向其中的nodes数组push node
                    cluster.nodes.push(node);// cluster={"cluster_id":1, nodes:[]}
                }
            }
            //cluster边
            for(const edge of this.graphData.edges){
                const scid = nodesById[edge.source].properties.cluster_id
                const tcid = nodesById[edge.target].properties.cluster_id
                //若这两个类已经存在边，忽略
                var found = clusterData.clusterEdges.find(cedge => cedge.source==("c"+scid) && cedge.target==("c"+tcid) )
                //若这两个类不存在边，建立
                if(!found){
                    clusterData.clusterEdges.push({"source":"c"+scid,"target":"c"+tcid,count:1});
                    console.log("建立类之间的边","source",scid,"target",tcid)
                }else{ //已存在，则让count+1
                    found.count+=1;
                }
            }
            // TODO: 临时加
            clusterData.clusterEdges.push({"source":"c0","target":"c0",count:1});
            clusterData.clusterEdges.push({"source":"c10","target":"c10",count:1});
            clusterData.clusterEdges.push({"source":"c11","target":"c11",count:1});

            console.log("最终的clusterData：",clusterData)
            return clusterData
        },
        show(){
            var containerId = "group-container"
            // 实际开发中把 window.AntVUtil 换成从 @antv/util 引入的相关模块
            // replace window.AntVUtil.isObject with
            // import { isNumber, isArray } from '@antv/util';
            //TODO: #363b40为黑色背景色
            insertCss(`
            .g6-component-contextmenu {
                position: absolute;
                z-index: 2;
                list-style-type: none;
                background-color: #363b40; 
                border-radius: 6px;
                font-size: 14px;
                color: hsla(0,0%,100%,.85);
                width: fit-content;
                transition: opacity .2s;
                text-align: center;
                padding: 0px 20px 0px 20px;
                    box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.6);
                    border: 0px;
            }
            .g6-component-contextmenu ul {
                    padding-left: 0px;
                    margin: 0;
            }
            .g6-component-contextmenu li {
                cursor: pointer;
                list-style-type: none;
                list-style: none;
                margin-left: 0;
                line-height: 38px;
            }
            .g6-component-contextmenu li:hover {
                color: #aaaaaa;
                }

                .g6-toolbar-ul {
                    position: absolute;
                    top: 70px;
                    border: 1px solid #e2e2e2;
                    border-radius: 4px;
                    font-size: 12px;
                    color: #545454;
                    background-color: rgba(255, 255, 255, 0.9);
                    padding: 10px 8px;
                    box-shadow: rgb(174, 174, 174) 0px 0px 10px;
                    width: 100px;
                    cursor: pointer;
                }
            `);

            const { labelPropagation, louvain, findShortestPath } = G6.Algorithm;
            const { uniqueId } = G6.Util;

            const NODESIZEMAPPING = 'degree';
            const SMALLGRAPHLABELMAXLENGTH = 5;
            let labelMaxLength = SMALLGRAPHLABELMAXLENGTH;
            const DEFAULTNODESIZE = 20;
            const DEFAULTAGGREGATEDNODESIZE = 53;
            const NODE_LIMIT = 40; // TODO: 可展示的最大节点数量find a proper number for maximum node number on the canvas
            //////////////////////////////////////////////////////////
            const canvasBackgroundColor = '#363b40';
            const darkBackColor = 'rgb(43, 47, 51)'; //TODO:这里修改节点的背景颜色 原本rgb(43, 47, 51)
            const disableColor = '#777';
            const theme = 'dark'; //原本为dark  可选：dark、default
            const subjectColors = [
                '#5F95FF', // blue
                '#61DDAA',
                '#65789B',
                '#F6BD16',
                '#7262FD',
                '#78D3F8',
                '#9661BC',
                '#F6903D',
                '#008685',
                '#F08BB4', //pink
                '#DD6572', //red
                '#FFEEB3', //yellow
                '#BAABDA', //purple
                '#85C2FF' //blue
            ];
            const colorSets = G6.Util.getColorSetsBySubjectColors(
                subjectColors,
                darkBackColor,
                theme,
                disableColor,
            );
            /////////////////////////////////////////////////////
            let graph = null;
            let currentUnproccessedData = { nodes: [], edges: [] };
            let nodeMap = {};
            let aggregatedNodeMap = {};
            let hiddenItemIds = []; // 隐藏的元素 id 数组
            let largeGraphMode = true;
            let cachePositions = {};
            let manipulatePosition = undefined;
            let descreteNodeCenter;
            let layout = {
                type: '',
                instance: null,
                destroyed: true,
            };
            let expandArray = [];
            let collapseArray = [];
            let shiftKeydown = false;
            let CANVAS_WIDTH = 800,
            CANVAS_HEIGHT = 800;

            const duration = 2000;
            const animateOpacity = 0.6;
            const animateBackOpacity = 0.1;
            const virtualEdgeOpacity = 0.1;
            const realEdgeOpacity = 0.2;

            const global = {
                node: {
                    style: {
                        fill: '#2B384E',
                    },
                    labelCfg: {
                        style: {
                            fill: '#acaeaf',
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            fill: '#2B384E',
                        },
                    },
                },
                edge: {
                    style: {
                        stroke: '#acaeaf',
                        realEdgeStroke: '#acaeaf', //'#f00',
                        realEdgeOpacity,
                        strokeOpacity: realEdgeOpacity,
                    },
                    labelCfg: {
                        style: {
                            fill: '#acaeaf',
                            realEdgeStroke: '#acaeaf', //'#f00',
                            realEdgeOpacity: 0.5,
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            stroke: '#fff', // '#3C9AE8',
                        },
                    },
                },
            };
            // Custom super node
            G6.registerNode(
            'aggregated-node',
            {
                draw(cfg, group) {
                let width = 53,
                    height = 27;
                const style = cfg.style || {};
                const colorSet = cfg.colorSet || colorSets[0];

                // halo for hover
                group.addShape('rect', {
                    attrs: {
                    x: -width * 0.55,
                    y: -height * 0.6,
                    width: width * 1.1,
                    height: height * 1.2,
                    fill: colorSet.mainFill,
                    opacity: 0.9,
                    lineWidth: 0,
                    radius: (height / 2 || 13) * 1.2,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'halo-shape',
                    visible: false,
                });

                // focus stroke for hover
                group.addShape('rect', {
                    attrs: {
                    x: -width * 0.55,
                    y: -height * 0.6,
                    width: width * 1.1,
                    height: height * 1.2,
                    fill: colorSet.mainFill, // '#3B4043',
                    stroke: '#AAB7C4',
                    lineWidth: 1,
                    lineOpacty: 0.85,
                    radius: (height / 2 || 13) * 1.2,
                    },
                    name: 'stroke-shape',
                    visible: false,
                });

                const keyShape = group.addShape('rect', {
                    attrs: {
                    ...style,
                    x: -width / 2,
                    y: -height / 2,
                    width,
                    height,
                    fill: colorSet.mainFill, // || '#3B4043',
                    stroke: colorSet.mainStroke,
                    lineWidth: 2,
                    cursor: 'pointer',
                    radius: height / 2 || 13,
                    lineDash: [2, 2],
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'aggregated-node-keyShape',
                });

                let labelStyle = {};
                if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                }
                group.addShape('text', {
                    attrs: {
                        text: `${cfg.count}`,
                        x: 0,
                        y: 0,
                        textAlign: 'center',
                        textBaseline: 'middle',
                        cursor: 'pointer',
                        fontSize: 12,
                        fill: '#fff',
                        opacity: 0.85,
                        fontWeight: 400,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'count-shape',
                    className: 'count-shape',
                    draggable: true,
                });

                // tag for new node
                if (cfg.new) {
                    group.addShape('circle', {
                    attrs: {
                        x: width / 2 - 3,
                        y: -height / 2 + 3,
                        r: 4,
                        fill: '#6DD400',
                        lineWidth: 0.5,
                        stroke: '#FFFFFF',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'typeNode-tag-circle',
                    });
                }
                return keyShape;
                },
                setState: (name, value, item) => {
                const group = item.get('group');
                if (name === 'layoutEnd' && value) {
                    const labelShape = group.find((e) => e.get('name') === 'text-shape');
                    if (labelShape) labelShape.set('visible', true);
                } else if (name === 'hover') {
                    if (item.hasState('focus')) {
                    return;
                    }
                    const halo = group.find((e) => e.get('name') === 'halo-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    halo && halo.show();
                    keyShape.attr('fill', colorSet.activeFill);
                    } else {
                    halo && halo.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                } else if (name === 'focus') {
                    const stroke = group.find((e) => e.get('name') === 'stroke-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    stroke && stroke.show();
                    keyShape.attr('fill', colorSet.selectedFill);
                    } else {
                    stroke && stroke.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                }
                },
                update: undefined,
            },
            'single-node',
            );

            // Custom real node
            G6.registerNode(
            'real-node',
            {
                draw(cfg, group) {
                let r = 30;
                if (isNumber(cfg.size)) {
                    r = cfg.size / 2;
                } else if (isArray(cfg.size)) {
                    r = cfg.size[0] / 2;
                }
                const style = cfg.style || {};
                const colorSet = cfg.colorSet || colorSets[0];

                // halo for hover
                group.addShape('circle', {
                    attrs: {
                    x: 0,
                    y: 0,
                    r: r + 5,
                    fill: style.fill || colorSet.mainFill || '#2B384E',
                    opacity: 0.9,
                    lineWidth: 0,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'halo-shape',
                    visible: false,
                });

                // focus stroke for hover
                group.addShape('circle', {
                    attrs: {
                    x: 0,
                    y: 0,
                    r: r + 5,
                    fill: style.fill || colorSet.mainFill || '#2B384E',
                    stroke: '#fff',
                    strokeOpacity: 0.85,
                    lineWidth: 1,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'stroke-shape',
                    visible: false,
                });

                const keyShape = group.addShape('circle', {
                    attrs: {
                    ...style,
                    x: 0,
                    y: 0,
                    r,
                    fill: colorSet.mainFill,
                    stroke: colorSet.mainStroke,
                    lineWidth: 2,
                    cursor: 'pointer',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'aggregated-node-keyShape',
                });

                let labelStyle = {};
                if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                }

                if (cfg.label) {
                    const text = cfg.label;
                    let labelStyle = {};
                    let refY = 0;
                    if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                    refY += cfg.labelCfg.refY || 0;
                    }
                    let offsetY = 0;
                    const fontSize = labelStyle.fontSize < 8 ? 8 : labelStyle.fontSize;
                    const lineNum = cfg.labelLineNum || 1;
                    offsetY = lineNum * (fontSize || 12);
                    group.addShape('text', {
                    attrs: {
                        text,
                        x: 0,
                        y: r + refY + offsetY + 5,
                        textAlign: 'center',
                        textBaseLine: 'alphabetic',
                        cursor: 'pointer',
                        fontSize,
                        fill: '#fff',
                        opacity: 0.85,
                        fontWeight: 400,
                        stroke: global.edge.labelCfg.style.stroke,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'text-shape',
                    className: 'text-shape',
                    });
                }

                // tag for new node
                if (cfg.new) {
                    group.addShape('circle', {
                    attrs: {
                        x: r - 3,
                        y: -r + 3,
                        r: 4,
                        fill: '#6DD400',
                        lineWidth: 0.5,
                        stroke: '#FFFFFF',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'typeNode-tag-circle',
                    });
                }

                return keyShape;
                },
                setState: (name, value, item) => {
                const group = item.get('group');
                if (name === 'layoutEnd' && value) {
                    const labelShape = group.find((e) => e.get('name') === 'text-shape');
                    if (labelShape) labelShape.set('visible', true);
                } else if (name === 'hover') {
                    if (item.hasState('focus')) {
                    return;
                    }
                    const halo = group.find((e) => e.get('name') === 'halo-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    halo && halo.show();
                    keyShape.attr('fill', colorSet.activeFill);
                    } else {
                    halo && halo.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                } else if (name === 'focus') {
                    const stroke = group.find((e) => e.get('name') === 'stroke-shape');
                    const label = group.find((e) => e.get('name') === 'text-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    stroke && stroke.show();
                    keyShape.attr('fill', colorSet.selectedFill);
                    label && label.attr('fontWeight', 800);
                    } else {
                    stroke && stroke.hide();
                    keyShape.attr('fill', colorSet.mainFill); // '#2B384E'
                    label && label.attr('fontWeight', 400);
                    }
                }
                },
                update: undefined,
            },
            'aggregated-node',
            ); // 这样可以继承 aggregated-node 的 setState

            // Custom the quadratic edge for multiple edges between one node pair
            G6.registerEdge(
            'custom-quadratic',
            {
                setState: (name, value, item) => {
                const group = item.get('group');
                const model = item.getModel();
                if (name === 'focus') {
                    const back = group.find((ele) => ele.get('name') === 'back-line');
                    if (back) {
                    back.stopAnimate();
                    back.remove();
                    back.destroy();
                    }
                    const keyShape = group.find((ele) => ele.get('name') === 'edge-shape');
                    const arrow = model.style.endArrow;
                    if (value) {
                    if (keyShape.cfg.animation) {
                        keyShape.stopAnimate(true);
                    }
                    keyShape.attr({
                        strokeOpacity: animateOpacity,
                        opacity: animateOpacity,
                        stroke: '#fff',
                        endArrow: {
                        ...arrow,
                        stroke: '#fff',
                        fill: '#fff',
                        },
                    });
                    if (model.isReal) {
                        const { lineWidth, path, endArrow, stroke } = keyShape.attr();
                        const back = group.addShape('path', {
                        attrs: {
                            lineWidth,
                            path,
                            stroke,
                            endArrow,
                            opacity: animateBackOpacity,
                        },
                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                        name: 'back-line',
                        });
                        back.toBack();
                        const length = keyShape.getTotalLength();
                        keyShape.animate(
                        (ratio) => {
                            // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations
                            const startLen = ratio * length;
                            // Calculate the lineDash
                            const cfg = {
                            lineDash: [startLen, length - startLen],
                            };
                            return cfg;
                        },
                        {
                            repeat: true, // Whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    } else {
                        let index = 0;
                        const lineDash = keyShape.attr('lineDash');
                        const totalLength = lineDash[0] + lineDash[1];
                        keyShape.animate(
                        () => {
                            index++;
                            if (index > totalLength) {
                            index = 0;
                            }
                            const res = {
                            lineDash,
                            lineDashOffset: -index,
                            };
                            // returns the modified configurations here, lineDash and lineDashOffset here
                            return res;
                        },
                        {
                            repeat: true, // whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    }
                    } else {
                    keyShape.stopAnimate();
                    const stroke = '#acaeaf';
                    const opacity = model.isReal ? realEdgeOpacity : virtualEdgeOpacity;
                    keyShape.attr({
                        stroke,
                        strokeOpacity: opacity,
                        opacity,
                        endArrow: {
                        ...arrow,
                        stroke,
                        fill: stroke,
                        },
                    });
                    }
                }
                },
            },
            'quadratic',
            );

            // Custom the line edge for single edge between one node pair
            G6.registerEdge(
            'custom-line',
            {
                setState: (name, value, item) => {
                const group = item.get('group');
                const model = item.getModel();
                if (name === 'focus') {
                    const keyShape = group.find((ele) => ele.get('name') === 'edge-shape');
                    const back = group.find((ele) => ele.get('name') === 'back-line');
                    if (back) {
                    back.stopAnimate();
                    back.remove();
                    back.destroy();
                    }
                    const arrow = model.style.endArrow;
                    if (value) {
                    if (keyShape.cfg.animation) {
                        keyShape.stopAnimate(true);
                    }
                    keyShape.attr({
                        strokeOpacity: animateOpacity,
                        opacity: animateOpacity,
                        stroke: '#fff',
                        endArrow: {
                        ...arrow,
                        stroke: '#fff',
                        fill: '#fff',
                        },
                    });
                    if (model.isReal) {
                        const { path, stroke, lineWidth } = keyShape.attr();
                        const back = group.addShape('path', {
                        attrs: {
                            path,
                            stroke,
                            lineWidth,
                            opacity: animateBackOpacity,
                        },
                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                        name: 'back-line',
                        });
                        back.toBack();
                        const length = keyShape.getTotalLength();
                        keyShape.animate(
                        (ratio) => {
                            // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations
                            const startLen = ratio * length;
                            // Calculate the lineDash
                            const cfg = {
                            lineDash: [startLen, length - startLen],
                            };
                            return cfg;
                        },
                        {
                            repeat: true, // Whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    } else {
                        const lineDash = keyShape.attr('lineDash');
                        const totalLength = lineDash[0] + lineDash[1];
                        let index = 0;
                        keyShape.animate(
                        () => {
                            index++;
                            if (index > totalLength) {
                            index = 0;
                            }
                            const res = {
                            lineDash,
                            lineDashOffset: -index,
                            };
                            // returns the modified configurations here, lineDash and lineDashOffset here
                            return res;
                        },
                        {
                            repeat: true, // whether executes the animation repeatly
                            duration, // the duration for executing once
                        },
                        );
                    }
                    } else {
                    keyShape.stopAnimate();
                    const stroke = '#acaeaf';
                    const opacity = model.isReal ? realEdgeOpacity : virtualEdgeOpacity;
                    keyShape.attr({
                        stroke,
                        strokeOpacity: opacity,
                        opacity: opacity,
                        endArrow: {
                        ...arrow,
                        stroke,
                        fill: stroke,
                        },
                    });
                    }
                }
                },
            },
            'single-edge',
            );

            const descendCompare = (p) => {
                // 这是比较函数
                return function (m, n) {
                    const a = m[p];
                    const b = n[p];
                    return b - a; // 降序
                };
            };

            const clearFocusItemState = (graph) => {
                if (!graph) return;
                clearFocusNodeState(graph);
                clearFocusEdgeState(graph);
            };

            // 清除图上所有节点的 focus 状态及相应样式
            const clearFocusNodeState = (graph) => {
                const focusNodes = graph.findAllByState('node', 'focus');
                focusNodes.forEach((fnode) => {
                    graph.setItemState(fnode, 'focus', false); // false
                });
            };

            // 清除图上所有边的 focus 状态及相应样式
            const clearFocusEdgeState = (graph) => {
                const focusEdges = graph.findAllByState('edge', 'focus');
                focusEdges.forEach((fedge) => {
                    graph.setItemState(fedge, 'focus', false);
                });
            };

            // 截断长文本。length 为文本截断后长度，elipsis 是后缀
            const formatText = (text, length = 5, elipsis = '...') => {
                if (!text) return '';
                if (text.length > length) {
                    return `${text.substr(0, length)}${elipsis}`;
                }
                return text;
            };

            const labelFormatter = (text, minLength = 10) => {
                if (text && text.split('').length > minLength) return `${text.substr(0, minLength)}...`;
                return text;
            };

            const processNodesEdges = (
                nodes,
                edges,
                width,
                height,
                largeGraphMode,
                edgeLabelVisible,
                isNewGraph = false,
            ) => {
                if (!nodes || nodes.length === 0) return {};
                const currentNodeMap = {};
                let maxNodeCount = -Infinity;
                const paddingRatio = 0.3;
                const paddingLeft = paddingRatio * width;
                const paddingTop = paddingRatio * height;
                nodes.forEach((node) => {
                    node.type = node.level === 0 ? 'real-node' : 'aggregated-node';
                    node.isReal = node.level === 0 ? true : false;
                    // node.label = `${node.id}`;
                    if(node.level===0){
                        //node.label = node.properties.name  //以域名作为节点的显示名称
                        node.label = node.properties.Website_title //以网站名称作为显示名称
                    }else{
                        node.label = node.id;
                    }
                    // node.label = node.properties.name || node.id;
                    node.labelLineNum = undefined;
                    node.oriLabel = node.label;
                    node.label = formatText(node.label, labelMaxLength, '...');
                    node.degree = 0;
                    node.inDegree = 0;
                    node.outDegree = 0;
                    if (currentNodeMap[node.id]) {
                        console.warn('node exists already!', node.id);
                        node.id = `${node.id}${Math.random()}`;
                    }
                    currentNodeMap[node.id] = node;
                    if (node.count > maxNodeCount) maxNodeCount = node.count;
                    const cachePosition = cachePositions ? cachePositions[node.id] : undefined;
                    if (cachePosition) {
                        node.x = cachePosition.x;
                        node.y = cachePosition.y;
                        node.new = false;
                    } else {
                        node.new = isNewGraph ? false : true;
                    if (manipulatePosition && !node.x && !node.y) {
                        node.x = manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);
                        node.y = manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);
                    }   
                    }
                });

                let maxCount = -Infinity;
                let minCount = Infinity;
                // let maxCount = 0;
                edges.forEach((edge) => {
                    // to avoid the dulplicated id to nodes
                    if (!edge.id) edge.id = uniqueId('edge');
                    else if (edge.id.split('-')[0] !== 'edge') edge.id = `edge-${edge.id}`;
                    // TODO: delete the following line after the queried data is correct
                    if (!currentNodeMap[edge.source] || !currentNodeMap[edge.target]) {
                    console.warn('edge source target does not exist', edge.source, edge.target, edge.id);
                    return;
                    }
                    const sourceNode = currentNodeMap[edge.source];
                    const targetNode = currentNodeMap[edge.target];

                    if (!sourceNode || !targetNode)
                    console.warn('source or target is not defined!!!', edge, sourceNode, targetNode);

                    // calculate the degree
                    sourceNode.degree++;
                    targetNode.degree++;
                    sourceNode.outDegree++;
                    targetNode.inDegree++;

                    if (edge.count > maxCount) maxCount = edge.count;
                    if (edge.count < minCount) minCount = edge.count;
                });

                nodes.sort(descendCompare(NODESIZEMAPPING));
                const maxDegree = nodes[0].degree || 1;

                const descreteNodes = [];
                nodes.forEach((node, i) => {
                    // assign the size mapping to the outDegree
                    const countRatio = node.count / maxNodeCount;
                    const isRealNode = node.level === 0;
                    node.size = isRealNode ? DEFAULTNODESIZE : DEFAULTAGGREGATEDNODESIZE;
                    node.isReal = isRealNode;
                    node.labelCfg = {
                        position: 'bottom',
                        offset: 5,
                        style: {
                            fill: global.node.labelCfg.style.fill,
                            fontSize: 6 + countRatio * 6 || 12,
                            stroke: global.node.labelCfg.style.stroke,
                            lineWidth: 3,
                        },
                    };

                    if (!node.degree) {
                    descreteNodes.push(node);
                    }
                });

                const countRange = maxCount - minCount;
                const minEdgeSize = 1;
                const maxEdgeSize = 7;
                const edgeSizeRange = maxEdgeSize - minEdgeSize;
                edges.forEach((edge) => {
                    // set edges' style
                    const targetNode = currentNodeMap[edge.target];

                    const size = ((edge.count - minCount) / countRange) * edgeSizeRange + minEdgeSize || 1;
                    edge.size = size;

                    const arrowWidth = Math.max(size / 2 + 2, 3);
                    const arrowLength = 10;
                    const arrowBeging = targetNode.size + arrowLength;
                    let arrowPath = `M ${arrowBeging},0 L ${arrowBeging + arrowLength},-${arrowWidth} L ${arrowBeging + arrowLength
                    },${arrowWidth} Z`;
                    let d = targetNode.size / 2 + arrowLength;
                    if (edge.source === edge.target) {
                        edge.type = 'loop';
                        arrowPath = undefined;
                    }
                    const sourceNode = currentNodeMap[edge.source];
                    const isRealEdge = targetNode.isReal && sourceNode.isReal;
                    edge.isReal = isRealEdge;
                    const stroke = isRealEdge ? global.edge.style.realEdgeStroke : global.edge.style.stroke;
                    const opacity = isRealEdge
                    ? global.edge.style.realEdgeOpacity
                    : global.edge.style.strokeOpacity;
                    const dash = Math.max(size, 2);
                    const lineDash = isRealEdge ? undefined : [dash, dash];
                    //TODO:边样式
                    edge.style = { 
                        stroke,
                        strokeOpacity: opacity,
                        cursor: 'pointer',
                        lineAppendWidth: Math.max(edge.size || 5, 5),
                        fillOpacity: 1,
                        lineDash,
                        endArrow: arrowPath
                            ? {
                            path: arrowPath,
                            d,
                            fill: stroke,
                            strokeOpacity: 0,
                            }
                            : false,
                    };
                    edge.labelCfg = {
                        autoRotate: true,
                        style: {
                            stroke: global.edge.labelCfg.style.stroke, //边的label的样式
                            fill: global.edge.labelCfg.style.fill,
                            lineWidth: 4,
                            fontSize: 12,
                            lineAppendWidth: 10,
                            opacity: 1,
                        },
                    };
                    if (!edge.oriLabel) edge.oriLabel = edge.label;
                    if (largeGraphMode || !edgeLabelVisible) edge.label = '';
                    else {
                    edge.label = labelFormatter(edge.label, labelMaxLength);
                    }

                    // arrange the other nodes around the hub
                    const sourceDis = sourceNode.size / 2 + 20;
                    const targetDis = targetNode.size / 2 + 20;
                    if (sourceNode.x && !targetNode.x) {
                    targetNode.x = sourceNode.x + sourceDis * Math.cos(Math.random() * Math.PI * 2);
                    }
                    if (sourceNode.y && !targetNode.y) {
                    targetNode.y = sourceNode.y + sourceDis * Math.sin(Math.random() * Math.PI * 2);
                    }
                    if (targetNode.x && !sourceNode.x) {
                    sourceNode.x = targetNode.x + targetDis * Math.cos(Math.random() * Math.PI * 2);
                    }
                    if (targetNode.y && !sourceNode.y) {
                    sourceNode.y = targetNode.y + targetDis * Math.sin(Math.random() * Math.PI * 2);
                    }

                    if (!sourceNode.x && !sourceNode.y && manipulatePosition) {
                    sourceNode.x = manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);
                    sourceNode.y = manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);
                    }
                    if (!targetNode.x && !targetNode.y && manipulatePosition) {
                    targetNode.x = manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);
                    targetNode.y = manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);
                    }
                });

                descreteNodeCenter = {
                    x: width - paddingLeft,
                    y: height - paddingTop,
                };
                descreteNodes.forEach((node) => {
                    if (!node.x && !node.y) {
                    node.x = descreteNodeCenter.x + 30 * Math.cos(Math.random() * Math.PI * 2);
                    node.y = descreteNodeCenter.y + 30 * Math.sin(Math.random() * Math.PI * 2);
                    }
                });

                G6.Util.processParallelEdges(edges, 12.5, 'custom-quadratic', 'custom-line');
                return {
                    maxDegree,
                    edges,
                };
            };

            const getForceLayoutConfig = (graph, largeGraphMode, configSettings) => {
                let {
                    linkDistance,
                    edgeStrength,
                    nodeStrength,
                    nodeSpacing,
                    preventOverlap,
                    nodeSize,
                    collideStrength,
                    alpha,
                    alphaDecay,
                    alphaMin,
                } = configSettings || { preventOverlap: true };

                if (!linkDistance && linkDistance !== 0) linkDistance = 225;
                if (!edgeStrength && edgeStrength !== 0) edgeStrength = 50;
                if (!nodeStrength && nodeStrength !== 0) nodeStrength = 200;
                if (!nodeSpacing && nodeSpacing !== 0) nodeSpacing = 5;

                const config = {
                    type: 'gForce',
                    minMovement: 0.01,
                    maxIteration: 5000,
                    preventOverlap,
                    damping: 0.99,
                    linkDistance: (d) => {
                        // console.log('nodemap',nodeMap)
                        // console.log('aggregatedNodeMap',aggregatedNodeMap)
                        // console.log(d.source,d.target) //c3 c3
                        let dist = linkDistance;
                        const sourceNode = nodeMap[d.source] || aggregatedNodeMap[d.source];
                        const targetNode = nodeMap[d.target] || aggregatedNodeMap[d.target];
                        // console.log(sourceNode,targetNode)
                        // // 两端都是聚合点
                        // if (sourceNode.level && targetNode.level) dist = linkDistance * 3;
                        // // 一端是聚合点，一端是真实节点
                        // else if (sourceNode.level || targetNode.level) dist = linkDistance * 1.5;
                        
                        if (!sourceNode.level && !targetNode.level) dist = linkDistance * 0.3;
                        return dist;
                    },
                    edgeStrength: (d) => {
                        const sourceNode = nodeMap[d.source] || aggregatedNodeMap[d.source];
                        const targetNode = nodeMap[d.target] || aggregatedNodeMap[d.target];
                        // 聚合节点之间的引力小
                        if (sourceNode.level && targetNode.level) return edgeStrength / 2;
                        // 聚合节点与真实节点之间引力大
                        if (sourceNode.level || targetNode.level) return edgeStrength;
                        return edgeStrength;
                    },
                    nodeStrength: (d) => {
                        // 给离散点引力，让它们聚集
                        if (d.degree === 0) return -10;
                        // 聚合点的斥力大
                        if (d.level) return nodeStrength * 2;
                        return nodeStrength;
                    },
                    nodeSize: (d) => {
                        if (!nodeSize && d.size) return d.size;
                        return 50;
                    },
                    nodeSpacing: (d) => {
                        if (d.degree === 0) return nodeSpacing * 2;
                        if (d.level) return nodeSpacing;
                        return nodeSpacing;
                    },
                    onLayoutEnd: () => {
                    if (largeGraphMode) {
                        graph.getEdges().forEach((edge) => {
                        if (!edge.oriLabel) return;
                        edge.update({
                            label: labelFormatter(edge.oriLabel, labelMaxLength),
                        });
                        });
                    }
                    },
                    tick: () => {
                    graph.refreshPositions();
                    },
                };

                if (nodeSize) config['nodeSize'] = nodeSize;
                if (collideStrength) config['collideStrength'] = collideStrength;
                if (alpha) config['alpha'] = alpha;
                if (alphaDecay) config['alphaDecay'] = alphaDecay;
                if (alphaMin) config['alphaMin'] = alphaMin;

                return config;
            };

            const hideItems = (graph) => {
                hiddenItemIds.forEach((id) => {
                    graph.hideItem(id);
                });
            };

            const showItems = (graph) => {
                graph.getNodes().forEach((node) => {
                    if (!node.isVisible()) graph.showItem(node);
                });
                graph.getEdges().forEach((edge) => {
                    if (!edge.isVisible()) edge.showItem(edge);
                });
                hiddenItemIds = [];
            };

            const handleRefreshGraph = (
                graph,
                graphData,
                width,
                height,
                largeGraphMode,
                edgeLabelVisible,
                isNewGraph,
            ) => {
                if (!graphData || !graph) return;
                clearFocusItemState(graph);
                // reset the filtering
                graph.getNodes().forEach((node) => {
                    if (!node.isVisible()) node.show();
                });
                graph.getEdges().forEach((edge) => {
                    if (!edge.isVisible()) edge.show();
                });

                let nodes = [],
                    edges = [];

                nodes = graphData.nodes;
                const processRes = processNodesEdges(
                    nodes,
                    graphData.edges || [],
                    width,
                    height,
                    largeGraphMode,
                    edgeLabelVisible,
                    isNewGraph,
                );

                edges = processRes.edges;

                graph.changeData({ nodes, edges });

                hideItems(graph);
                graph.getNodes().forEach((node) => {
                    node.toFront();
                });

                // layout.instance.stop();
                // force 需要使用不同 id 的对象才能进行全新的布局，否则会使用原来的引用。因此复制一份节点和边作为 force 的布局数据
                layout.instance.init({
                    nodes: graphData.nodes,
                    edges,
                });

                layout.instance.minMovement = 0.0001;
                // layout.instance.getCenter = d => {
                // 	const cachePosition = cachePositions[d.id];
                // 	if (!cachePosition && (d.x || d.y)) return [d.x, d.y, 10];
                // 	else if (cachePosition) return [cachePosition.x, cachePosition.y, 10];
                // 	return [width / 2, height / 2, 10];
                // }
                layout.instance.getMass = (d) => {
                    const cachePosition = cachePositions[d.id];
                    if (cachePosition) return 5;
                    return 1;
                };
                layout.instance.execute();
                return { nodes, edges };
            };

            const getMixedGraph = (
                aggregatedData,
                originData,
                nodeMap,
                aggregatedNodeMap,
                expandArray,
                collapseArray,
            ) => {
                let nodes = [],
                    edges = [];

                const expandMap = {},
                    collapseMap = {};
                expandArray.forEach((expandModel) => {
                    expandMap[expandModel.id] = true;
                });
                collapseArray.forEach((collapseModel) => {
                    collapseMap[collapseModel.id] = true;
                });
                console.log("aggregatedNodeMap",aggregatedNodeMap)
                console.log("expandMap",expandMap)
                aggregatedData.clusters.forEach((cluster, i) => {
                    if (expandMap["c"+cluster.id]) { //是待展开的cluster
                        nodes = nodes.concat(cluster.nodes);
                        //TODO: 如何保留原始的类节点？并添加边
                        nodes = nodes.concat(aggregatedNodeMap["c"+cluster.id])
                        aggregatedNodeMap["c"+cluster.id].expanded = true;
                        //// TODO:添加每个节点到聚合节点的边
                        cluster.nodes.forEach(node=>{
                            const vedge = {
                                target: node.id,
                                source: aggregatedNodeMap["c"+cluster.id].id,
                                id: uniqueId('edge'),
                                isReal:false,
                                label: '',
                            };
                            edges.push(vedge)
                        })
                        ////

                    } else {
                        nodes.push(aggregatedNodeMap["c"+cluster.id]);
                        aggregatedNodeMap["c"+cluster.id].expanded = false;
                    }
                });
                console.log("nodes",nodes)
                console.log("edges",edges)
                originData.edges.forEach((edge) => {
                    const isSourceInExpandArray = expandMap[nodeMap[edge.source].clusterId];
                    const isTargetInExpandArray = expandMap[nodeMap[edge.target].clusterId];
                    if (isSourceInExpandArray && isTargetInExpandArray) {
                        edges.push(edge);
                    } else if (isSourceInExpandArray) {
                        const targetClusterId = nodeMap[edge.target].clusterId;
                        const vedge = {
                            source: edge.source,
                            target: targetClusterId,
                            id: uniqueId('edge'),
                            label: '',
                        };
                        edges.push(vedge);
                    } else if (isTargetInExpandArray) {
                        const sourceClusterId = nodeMap[edge.source].clusterId;
                        const vedge = {
                            target: edge.target,
                            source: sourceClusterId,
                            id: uniqueId('edge'),
                            label: '',
                        };
                        edges.push(vedge);
                    }
                });
                aggregatedData.clusterEdges.forEach((edge) => {
                    if (expandMap[edge.source] || expandMap[edge.target]) return;
                    else edges.push(edge);
                });
                return { nodes, edges };
            };

            const getNeighborMixedGraph = (
                centerNodeModel,
                step,
                originData,
                clusteredData,
                currentData,
                nodeMap,
                aggregatedNodeMap,
                maxNeighborNumPerNode = 5,
            ) => {
                // update the manipulate position for center gravity of the new nodes
                manipulatePosition = { x: centerNodeModel.x, y: centerNodeModel.y };

                // the neighborSubGraph does not include the centerNodeModel. the elements are all generated new nodes and edges
                const neighborSubGraph = generateNeighbors(centerNodeModel, step, maxNeighborNumPerNode);
                // update the origin data
                originData.nodes = originData.nodes.concat(neighborSubGraph.nodes);
                originData.edges = originData.edges.concat(neighborSubGraph.edges);
                // update the origin nodeMap
                neighborSubGraph.nodes.forEach((node) => {
                    nodeMap[node.id] = node;
                });
                // update the clusteredData
                const clusterId = centerNodeModel.clusterId;
                clusteredData.clusters.forEach((cluster) => {
                    if (cluster.id !== clusterId) return;
                    cluster.nodes = cluster.nodes.concat(neighborSubGraph.nodes);
                    cluster.sumTot += neighborSubGraph.edges.length;
                });
                // update the count
                aggregatedNodeMap[clusterId].count += neighborSubGraph.nodes.length;

                currentData.nodes = currentData.nodes.concat(neighborSubGraph.nodes);
                currentData.edges = currentData.edges.concat(neighborSubGraph.edges);
                return currentData;
            };

            const generateNeighbors = (centerNodeModel, step, maxNeighborNumPerNode = 5) => {
                if (step <= 0) return undefined;
                let nodes = [],
                    edges = [];
                const clusterId = centerNodeModel.clusterId;
                const centerId = centerNodeModel.id;
                const neighborNum = Math.ceil(Math.random() * maxNeighborNumPerNode);
                for (let i = 0; i < neighborNum; i++) {
                    const neighborNode = {
                    id: uniqueId('node'),
                    clusterId,
                    level: 0,
                    colorSet: centerNodeModel.colorSet,
                    };
                    nodes.push(neighborNode);
                    const dire = Math.random() > 0.5;
                    const source = dire ? centerId : neighborNode.id;
                    const target = dire ? neighborNode.id : centerId;
                    const neighborEdge = {
                    id: uniqueId('edge'),
                    source,
                    target,
                    label: `${source}-${target}`,
                    };
                    edges.push(neighborEdge);
                    const subNeighbors = generateNeighbors(neighborNode, step - 1, maxNeighborNumPerNode);
                    if (subNeighbors) {
                    nodes = nodes.concat(subNeighbors.nodes);
                    edges = edges.concat(subNeighbors.edges);
                    }
                }
                return { nodes, edges };
            };

            const getExtractNodeMixedGraph = (
                extractNodeData,
                originData,
                nodeMap,
                aggregatedNodeMap,
                currentUnproccessedData,
            ) => {
                const extractNodeId = extractNodeData.id;
                // const extractNodeClusterId = extractNodeData.clusterId;
                // push to the current rendering data
                currentUnproccessedData.nodes.push(extractNodeData);
                // update the count of aggregatedNodeMap, when to revert?
                // aggregatedNodeMap[extractNodeClusterId].count --;

                // extract the related edges
                originData.edges.forEach((edge) => {
                    if (edge.source === extractNodeId) {
                    const targetClusterId = nodeMap[edge.target].clusterId;
                    if (!aggregatedNodeMap[targetClusterId].expanded) {
                        // did not expand, create an virtual edge fromt he extract node to the cluster
                        currentUnproccessedData.edges.push({
                        id: uniqueId('edge'),
                        source: extractNodeId,
                        target: targetClusterId,
                        });
                    } else {
                        // if the cluster is already expanded, push the origin edge
                        currentUnproccessedData.edges.push(edge);
                    }
                    } else if (edge.target === extractNodeId) {
                    const sourceClusterId = nodeMap[edge.source].clusterId;
                    if (!aggregatedNodeMap[sourceClusterId].expanded) {
                        // did not expand, create an virtual edge fromt he extract node to the cluster
                        currentUnproccessedData.edges.push({
                        id: uniqueId('edge'),
                        target: extractNodeId,
                        source: sourceClusterId,
                        });
                    } else {
                        // if the cluster is already expanded, push the origin edge
                        currentUnproccessedData.edges.push(edge);
                    }
                    }
                });
                return currentUnproccessedData;
            };

            const examAncestors = (model, expandedArray, length, keepTags) =>   {
                for (let i = 0; i < length; i++) {
                    const expandedNode = expandedArray[i];
                    if (!keepTags[i] && model.parentId === expandedNode.id) {
                    keepTags[i] = true; // 需要被保留
                    examAncestors(expandedNode, expandedArray, length, keepTags);
                    break;
                    }
                }
            };

            const manageExpandCollapseArray = (nodeNumber, model, collapseArray, expandArray) => {
                manipulatePosition = { x: model.x, y: model.y };

                // 维护 expandArray，若当前画布节点数高于上限，移出 expandedArray 中非 model 祖先的节点)
                if (nodeNumber > NODE_LIMIT) {
                    // 若 keepTags[i] 为 true，则 expandedArray 的第 i 个节点需要被保留
                    const keepTags = {};
                    const expandLen = expandArray.length;
                    // 检查 X 的所有祖先并标记 keepTags
                    examAncestors(model, expandArray, expandLen, keepTags);
                    // 寻找 expandedArray 中第一个 keepTags 不为 true 的点
                    let shiftNodeIdx = -1;
                    for (let i = 0; i < expandLen; i++) {
                    if (!keepTags[i]) {
                        shiftNodeIdx = i;
                        break;
                    }
                    }
                    // 如果有符合条件的节点，将其从 expandedArray 中移除
                    if (shiftNodeIdx !== -1) {
                    let foundNode = expandArray[shiftNodeIdx];
                    if (foundNode.level === 2) {
                        let foundLevel1 = false;
                        // 找到 expandedArray 中 parentId = foundNode.id 且 level = 1 的第一个节点
                        for (let i = 0; i < expandLen; i++) {
                        const eNode = expandArray[i];
                        if (eNode.parentId === foundNode.id && eNode.level === 1) {
                            foundLevel1 = true;
                            foundNode = eNode;
                            expandArray.splice(i, 1);
                            break;
                        }
                        }
                        // 若未找到，则 foundNode 不变, 直接删去 foundNode
                        if (!foundLevel1) expandArray.splice(shiftNodeIdx, 1);
                    } else {
                        // 直接删去 foundNode
                        expandArray.splice(shiftNodeIdx, 1);
                    }
                    // const removedNode = expandedArray.splice(shiftNodeIdx, 1); // splice returns an array
                    const idSplits = foundNode.id.split('-');
                    let collapseNodeId;
                    // 去掉最后一个后缀
                    for (let i = 0; i < idSplits.length - 1; i++) {
                        const str = idSplits[i];
                        if (collapseNodeId) collapseNodeId = `${collapseNodeId}-${str}`;
                        else collapseNodeId = str;
                    }
                    const collapseNode = {
                        id: collapseNodeId,
                        parentId: foundNode.id,
                        level: foundNode.level - 1,
                    };
                    collapseArray.push(collapseNode); //TODO:如何不隐藏父节点？、
                    console.log("collapseArray",collapseArray)
                    }
                }

                const currentNode = {
                    id: model.id,
                    level: model.level,
                    parentId: model.parentId,
                };

                // 加入当前需要展开的节点
                expandArray.push(currentNode);
                console.log("展开节点组",expandArray)
                graph.get('canvas').setCursor('default');
                return { expandArray, collapseArray };
            };

            const cacheNodePositions = (nodes) => {
                const positionMap = {};
                const nodeLength = nodes.length;
                for (let i = 0; i < nodeLength; i++) {
                    const node = nodes[i].getModel();
                    positionMap[node.id] = {
                    x: node.x,
                    y: node.y,
                    level: node.level,
                    };
                }
                return positionMap;
            };

            const stopLayout = () => {
                layout.instance.stop();
            };

            const bindListener = (graph) => {
                graph.on('keydown', (evt) => {
                    const code = evt.key;
                    if (!code) {
                    return;
                    }
                    if (code.toLowerCase() === 'shift') {
                    shiftKeydown = true;
                    } else {
                    shiftKeydown = false;
                    }
                });
                graph.on('keyup', (evt) => {
                    const code = evt.key;
                    if (!code) {
                    return;
                    }
                    if (code.toLowerCase() === 'shift') {
                    shiftKeydown = false;
                    }
                });
                graph.on('node:mouseenter', (evt) => {
                    const { item } = evt;
                    const model = item.getModel();
                    const currentLabel = model.label;
                    model.oriFontSize = model.labelCfg.style.fontSize;
                    item.update({
                    label: model.oriLabel,
                    });
                    model.oriLabel = currentLabel;
                    graph.setItemState(item, 'hover', true);
                    item.toFront();
                });

                graph.on('node:mouseleave', (evt) => {
                    const { item } = evt;
                    const model = item.getModel();
                    const currentLabel = model.label;
                    item.update({
                    label: model.oriLabel,
                    });
                    model.oriLabel = currentLabel;
                    graph.setItemState(item, 'hover', false);
                });

                graph.on('edge:mouseenter', (evt) => {
                    const { item } = evt;
                    const model = item.getModel();
                    const currentLabel = model.label;
                    item.update({
                    label: model.oriLabel,
                    });
                    model.oriLabel = currentLabel;
                    item.toFront();
                    item.getSource().toFront();
                    item.getTarget().toFront();
                });

                graph.on('edge:mouseleave', (evt) => {
                    const { item } = evt;
                    const model = item.getModel();
                    const currentLabel = model.label;
                    item.update({
                    label: model.oriLabel,
                    });
                    model.oriLabel = currentLabel;
                });
                // click node to show the detail drawer
                graph.on('node:click', (evt) => {
                    stopLayout();
                    if (!shiftKeydown) clearFocusItemState(graph);
                    else clearFocusEdgeState(graph);
                    const { item } = evt;

                    // highlight the clicked node, it is down by click-select
                    graph.setItemState(item, 'focus', true);

                    if (!shiftKeydown) {
                    // 将相关边也高亮
                    const relatedEdges = item.getEdges();
                    relatedEdges.forEach((edge) => {
                        graph.setItemState(edge, 'focus', true);
                    });
                    }
                });

                // click edge to show the detail of integrated edge drawer
                graph.on('edge:click', (evt) => {
                    stopLayout();
                    if (!shiftKeydown) clearFocusItemState(graph);
                    const { item } = evt;
                    // highlight the clicked edge
                    graph.setItemState(item, 'focus', true);
                });

                // click canvas to cancel all the focus state
                graph.on('canvas:click', (evt) => {
                    clearFocusItemState(graph);
                    console.log(graph.getGroup(), graph.getGroup().getBBox(), graph.getGroup().getCanvasBBox());
                });
            };

            const toolbar = new G6.ToolBar({
                // container: tc,
                className: 'g6-toolbar-ul',
                getContent: () => {
                    return `
                    <ul>
                        <li code='search'><i class='el-icon-search'></i></li>
                        <li code='undo'>撤销</li>
                        <li code='redo'>回退</li>
                    </ul>
                    `;
                },
                handleClick: (code, graph) => {
                    if (code === 'add') {
                    graph.addItem('node', {
                        id: 'node2',
                        label: 'node2',
                        x: 300,
                        y: 150,
                    });
                    } else if (code === 'undo') {
                    toolbar.undo();
                    } else if (code === 'redo') {
                    toolbar.redo();
                    }
                },
            });


            //TODO: https://gw.alipayobjects.com/os/antvdemo/assets/data/relations.json
            //api/graph/all
            // fetch('https://gw.alipayobjects.com/os/antvdemo/assets/data/relations.json')
            fetch('api/graph/clusters')
            .then((res) => res.json())
            .then((data) => {
                this.loading = false;
                const container = document.getElementById(containerId);
                container.style.backgroundColor = canvasBackgroundColor; //TODO:背景颜色?
                CANVAS_WIDTH = container.scrollWidth;
                CANVAS_HEIGHT = (container.scrollHeight || 480) - 30;

                nodeMap = {};
                // const clusteredData = louvain(data, false, 'weight');
                console.log(data)
                this.graphData=data;
                const clusteredData = this.showmy()
                this.getTimelineList(this.graphData.nodes);

                console.log('cluster data louvain',clusteredData)
                
                const aggregatedData = { nodes: [], edges: [] };
                clusteredData.clusters.forEach((cluster, i) => {
                    cluster.nodes.forEach((node) => {
                        node.level = 0;
                        //node.label = node.properties.name; //TODO:修改
                        node.type = '';
                        node.colorSet = colorSets[i];
                        nodeMap[node.id] = node;
                    });
                    const cnode = {
                        id: "c"+cluster.id,
                        // id: cluster.id,
                        type: 'aggregated-node',
                        count: cluster.nodes.length,
                        level: 1,
                        label: cluster.id,
                        colorSet: colorSets[i],
                        idx: i,
                    };
                    aggregatedNodeMap["c"+cluster.id] = cnode;
                    aggregatedData.nodes.push(cnode);
                });
                clusteredData.clusterEdges.forEach((clusterEdge) => {
                    const cedge = {
                        ...clusterEdge,
                        size:Math.log(clusterEdge.count),
                        // size: 1, //TODO:修改 Math.log(clusterEdge.count),
                        label: '',
                        id: uniqueId('edge'),
                    };
                    if (cedge.source === cedge.target) {
                        cedge.type = 'loop';
                        cedge.loopCfg = {
                            dist: 20,
                        };
                    } else cedge.type = 'line';
                    aggregatedData.edges.push(cedge);
                });

                console.log("clusteredData",clusteredData)
                console.log("aggregatedData",aggregatedData)
                // console.log("nodemap",nodeMap)
                data.edges.forEach((edge) => {
                    edge.label = `${edge.source}-${edge.target}`;
                    edge.id = uniqueId('edge');
                });

                currentUnproccessedData = aggregatedData;

                const { edges: processedEdges } = processNodesEdges(
                    currentUnproccessedData.nodes,
                    currentUnproccessedData.edges,
                    CANVAS_WIDTH,
                    CANVAS_HEIGHT,
                    largeGraphMode,
                    true,
                    true,
                );

                //TODO:上下文菜单
                const contextMenu = new G6.Menu({
                    shouldBegin(evt) {
                        if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) return true;
                        if (evt.item) return true;
                        return false;
                    },
                    getContent(evt) {
                        const { item } = evt;
                        if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) {
                        return `<ul>
                        <li id='show'>显示全部隐藏节点</li>
                        <li id='collapseAll'>折叠全部团伙</li>
                        </ul>`;
                        } else if (!item) return;
                        const itemType = item.getType();
                        const model = item.getModel();
                        if (itemType && model) {
                        if (itemType === 'node') {
                            if (model.level !== 0) {
                                console.log(model)
                                if(model.expanded==true){
                                    return `<ul>
                                        <li id='detail'>查看团伙详情</li>
                                        </ul>`;
                                } 
                            return `<ul>
                                <li id='expand'>展开团伙聚类</li>
                                <li id='detail'>查看团伙详情</li>
                                <li id='hide'>隐藏团伙</li>
                                </ul>`;
                            } 
                            else {
                                return `<ul>
                                <li id='collapse'>折叠团伙信息</li>
                                </ul>`;
                            }
                        } else {
                            return `<ul>
                            <li id='hide'>隐藏边</li>
                        </ul>`;
                        }
                        }
                    },
                    handleMenuClick: (target, item) => {
                        const model = item && item.getModel();
                        const liIdStrs = target.id.split('-');
                        let mixedGraphData;
                        switch (liIdStrs[0]) {
                        case 'hide':
                            graph.hideItem(item);
                            hiddenItemIds.push(model.id);
                            break;
                        case 'expand':
                            const newArray = manageExpandCollapseArray(
                                graph.getNodes().length,
                                model,
                                collapseArray,
                                expandArray,
                            );
                            expandArray = newArray.expandArray;
                            collapseArray = newArray.collapseArray;
                            mixedGraphData = getMixedGraph(
                                clusteredData,
                                data,
                                nodeMap,
                                aggregatedNodeMap,
                                expandArray,
                                collapseArray,
                            );
                            break;
                        case 'collapse':
                            const aggregatedNode = aggregatedNodeMap[model.clusterId];
                            manipulatePosition = { x: aggregatedNode.x, y: aggregatedNode.y };
                            collapseArray.push(aggregatedNode);
                            for (let i = 0; i < expandArray.length; i++) {
                            if (expandArray[i].id === model.clusterId) {
                                expandArray.splice(i, 1);
                                break;
                            }
                            }
                            mixedGraphData = getMixedGraph(
                                clusteredData,
                                data,
                                nodeMap,
                                aggregatedNodeMap,
                                expandArray,
                                collapseArray,
                            );
                            break;
                        case 'collapseAll':
                            expandArray = [];
                            collapseArray = [];
                            mixedGraphData = getMixedGraph(
                            clusteredData,
                            data,
                            nodeMap,
                            aggregatedNodeMap,
                            expandArray,
                            collapseArray,
                            );
                            break;
                        case 'neighbor':
                            const expandNeighborSteps = parseInt(liIdStrs[1]);
                            mixedGraphData = getNeighborMixedGraph(
                                model,
                                expandNeighborSteps,
                                data,
                                clusteredData,
                                currentUnproccessedData,
                                nodeMap,
                                aggregatedNodeMap,
                                10,
                            );
                            break;
                        case 'show':
                            showItems(graph);
                            break;
                        case 'detail':
                            // this.$router.push('/analyse/index')
                            const cid = model.id.substring(1)
                            console.log("查看团伙",cid)
                            this.$router.push({path:"/trace/analyse",query: {id: cid}})
                            break;
                        default:
                            break;
                        }
                        if (mixedGraphData) {
                            cachePositions = cacheNodePositions(graph.getNodes());
                            currentUnproccessedData = mixedGraphData;
                            handleRefreshGraph(
                                graph,
                                currentUnproccessedData,
                                CANVAS_WIDTH,
                                CANVAS_HEIGHT,
                                largeGraphMode,
                                true,
                                false,
                            );
                        }
                    },
                    // offsetX and offsetY include the padding of the parent container
                    // 需要加上父级容器的 padding-left 16 与自身偏移量 10
                    offsetX: 16 + 10,
                    // 需要加上父级容器的 padding-top 24 、画布兄弟元素高度、与自身偏移量 10
                    offsetY: 0,
                    // the types of items that allow the menu show up
                    // 在哪些类型的元素上响应
                    itemTypes: ['node', 'edge', 'canvas'],
                });

                graph = new G6.Graph({
                    container: containerId,
                    width: CANVAS_WIDTH,
                    height: CANVAS_HEIGHT,
                    linkCenter: true,
                    minZoom: 0.1,
                    groupByTypes: false,
                    modes: {
                        default: [
                        {
                            type: 'drag-canvas',
                            enableOptimize: true,
                        },
                        {
                            type: 'zoom-canvas',
                            enableOptimize: true,
                            optimizeZoom: 0.01,
                        },
                        'drag-node',
                        'shortcuts-call',
                        ],
                        lassoSelect: [
                        {
                            type: 'zoom-canvas',
                            enableOptimize: true,
                            optimizeZoom: 0.01,
                        },
                        {
                            type: 'lasso-select',
                            selectedState: 'focus',
                            trigger: 'drag',
                        },
                        ],
                        fisheyeMode: [],
                    },
                    defaultNode: {
                        type: 'aggregated-node',
                        size: DEFAULTNODESIZE,
                    },
                    plugins: [contextMenu],
                });

                graph.get('canvas').set('localRefresh', false);

                const layoutConfig = getForceLayoutConfig(graph, largeGraphMode);
                    layoutConfig.center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];
                    layout.instance = new G6.Layout['gForce'](layoutConfig);
                    layout.instance.init({
                    nodes: currentUnproccessedData.nodes,
                    edges: processedEdges,
                });
                layout.instance.execute();

                bindListener(graph);
                graph.data({ nodes: aggregatedData.nodes, edges: processedEdges });
                graph.render();
            });

            if (typeof window !== 'undefined')
            window.onresize = () => {
                if (!graph || graph.get('destroyed')) return;
                const container = document.getElementById(containerId);
                if (!container) return;
                graph.changeSize(container.scrollWidth, container.scrollHeight - 30);
            };
        },
        showScatter(){
            const data = [
            { x: 2013, y: 2 },
            { x: 2014, y: 2 },
            { x: 2015, y: 4 },
            { x: 2016, y: 5 },
            { x: 2017, y: 5 },
            { x: 2018, y: 8 },
            { x: 2019, y: 9 },
            { x: 2020, y: 11 },
            { x: 2021, y: 14 },
            { x: 2022, y: 15 },
            { x: 2023, y: 15 },
            ];
            const data2 = [
                    {
                        x:2015,
                        y:4,
                    },
                    {
                        x:2016,
                        y:5,
                    },
                    {
                        x:2017,
                        y:6,
                    },
                    {
                        x:2018,
                        y:8,
                    },
                    {
                        x:2019,
                        y:9,
                    },
                    {
                        x:2020,
                        y:11,
                    },
                    {
                        x:2021,
                        y:12,
                    },
                    {
                        x:2022,
                        y:15,
                    },
                    {
                        x:2023,
                        y:15,
                    },
                ]
            const scatterPlot = new Scatter('bubble-container', {
                data,
                xField: 'x',
                yField: 'y',
                size: 5,
                height:280,
                pointStyle: {
                    stroke: '#9A67BD',
                    lineWidth: 1,
                    fill: '#9A67BD',
                },
                shape: 'triangle',
                // regressionLine: {
                //     type: 'quad', // linear, exp, loess, log, poly, pow, quad
                // },
            });
            scatterPlot.render();
        },
        showBubble(){
            fetch('https://gw.alipayobjects.com/os/antfincdn/t81X1wXdoj/scatter-data.json')
            .then((res) => res.json())
            .then((data) => {
                const data2 = [
                    {
                        "x":2015,
                        "y":4,
                        "size":4,
                        "genre":"group"
                    },
                    {
                        x:2016,
                        y:5,
                        size:5,
                        genre:"group"
                    },
                    {
                        x:2017,
                        y:6,
                        size:6,
                        genre:"group"
                    },
                    {
                        x:2018,
                        y:8,
                        size:8,
                        genre:"group"
                    },
                    {
                        x:2019,
                        y:9,
                        size:9,
                        genre:"group"
                    },
                    {
                        x:2020,
                        y:11,
                        size:11,
                        genre:"group"
                    },
                    {
                        x:2021,
                        y:12,
                        size:12,
                        genre:"group"
                    },
                    {
                        x:2022,
                        y:15,
                        size:15,
                        genre:"group"
                    },
                    {
                        x:2023,
                        y:15,
                        size:15,
                        genre:"group"
                    },
                ]
                const scatterPlot = new Scatter('bubble-container', {
                appendPadding: 30,
                data2,
                xField: 'x',
                yField: 'y',
                colorField: 'genre',
                color: [
                    'r(0.4, 0.3, 0.7) 0:#939393 1:#5B8FF9',
                ],
                pointStyle: {
                    fillOpacity: 0.8,
                    stroke: '#5B8FF9',
                },
                sizeField: 'size',
                size: [5, 20],
                shape: 'circle',
                yAxis: {
                    nice: true,
                    line: {
                    style: {
                        stroke: '#eee',
                    },
                    },
                },
                xAxis: {
                    grid: {
                    line: {
                        style: {
                        stroke: '#eee',
                        },
                    },
                    },
                    line: {
                    style: {
                        stroke: '#eee',
                    },
                    },
                },
                });
                scatterPlot.render();
            });

        },
        currentPageData(){

        },
        getTimelineList(data){
            data.forEach(node => { 
                var color = this.subjectColors[
                    Math.floor(Math.random() * this.subjectColors.length)
                ];
                if(node.label=="Website"){
                    if(node.properties["recorded_time"]==undefined||node.properties["recorded_time"]=="0000-00-00" || node.properties["recorded_time"]==null){
                        node.properties["recorded_time"]='';
                    }
                    this.timelineList.push({
                        name:node.properties["name"],
                        time:node.properties["recorded_time"],
                        label:node.label,
                        cid:node.properties["cluster_id"],
                        color:color
                    })
                }else if(node.label=="Company"){
                    this.timelineList.push({
                        name:node.properties["name"],
                        time:node.properties["approval_date"],
                        label:node.label,
                        cid:node.properties["cluster_id"],
                        color:color
                    });
                }else if(node.label=="Person"){
                    this.timelineList.push({
                        name:node.properties["name"],
                        time:'',
                        label:node.label,
                        cid:node.properties["cluster_id"],
                        color:color
                    });
                }else if(node.label=="Ip"){
                    this.timelineList.push({
                        name:node.properties["name"],
                        time:'',
                        label:node.label,
                        cid:node.properties["cluster_id"],
                        color:color
                    });
                }
                // descend by time
                this.timelineList.sort((a, b) => {
                    if(a.time=='' || b.time=='' || a.time=="0000-00-00" || b.time=="0000-00-00" || a.time==null || b.time==null || a.time==undefined || b.time==undefined){
                        return 0;
                    }
                    return new Date(b.time) - new Date(a.time);
                });
            });
            this.timelineList = this.timelineList.slice(0,30)
            console.log(this.timelineList)
        },
        classifyNumbers(clusterList) {
            // 示例用法
            // const numbers = [80, 120, 30, 50, 150];
            const numbers = clusterList.map(obj => obj.count);
            var sortedNumbers = numbers.sort((a, b) => a - b);
            const maxNumber = sortedNumbers[sortedNumbers.length - 1];
            const minNumber = sortedNumbers[0];
            const range = maxNumber - minNumber;
            const thresholdLarge = maxNumber - range * 0.2; // 大的阈值
            const thresholdMedium = maxNumber - range * 0.7; // 中的阈值
            const result = [];
            sortedNumbers = numbers.sort((a, b) => b - a);
            console.log('大',thresholdLarge,'中',thresholdMedium)
            for (let i = 0; i < numbers.length; i++) {
                const obj = sortedNumbers[i];
                if (sortedNumbers[i] >= thresholdLarge) {
                    this.clusterCountList[i].size = "大型团伙";
                    result.push("大");
                } else if (sortedNumbers[i] >= thresholdMedium) {
                    this.clusterCountList[i].size = "中型团伙";
                    result.push("中");
                } else {
                    this.clusterCountList[i].size = "小型团伙";
                    result.push("小");
                }
            }
            console.log('大中小',result)
            console.log(this.clusterCountList)
            return result;
        }
    },
    mounted(){
        this.show();
        this.showScatter();
        // this.showBubble();
        // this.getAllWebsites()
    }
};
</script>

<style scoped>
.card-title{
    font-weight: bold;
    font-size: 16px;
    color: #c2c2c2;
    margin-bottom: 20px;
  }
    .page{
        padding:5px
    }

    /**修改canvas背景颜色   background-color: rgb(245, 234, 253) !important;**/
    .group-container{
        border-radius: 14px;
        height: 566px;
        /**
        height:566px;
        padding: 10px;
        margin: 10px;**/
        
    }
    .group-rank{
        height: 320px;
    }
    .timeline-card{
        height:566px;
    }

    .timeline-container{
        padding: 5px;
        height:510px;
    }

      .ant-timeline-item{
        color: #fff !important;
      }

    /deep/.el-row{
        margin-bottom:5px;
    }
    /deep/.el-statistic .head {
        margin-bottom: 4px;
        color: #b4b4b5;
        font-size: 13px;
    }

    /deep/.el-statistic .con .number {
        font-size: 20px;
        color: #b4b4b5;
        padding: 0 4px;
    }

    /deep/.el-divider {
        background-color: #585858 !important;
    }

    /deep/.el-table th.el-table__cell.is-leaf, .el-table td.el-table__cell {
        border-left: transparent;
    }


      
</style>

