<template>
    <div>
        <el-form label-position="left" label-width="140px" size="small" ref="path" :model="path" >
            <el-form-item prop="source" label="（起始）检索对象" :rules="[{ required: true, message: '节点信息不能为空'}]">
              <el-input v-model="path.source" placeholder="输入id"></el-input>
            </el-form-item>
            <el-form-item prop="target" label="（目标）检索对象" :rules="{ required: true, message: '节点信息不能为空'}">
              <el-input v-model="path.target"  placeholder="输入id"></el-input>
            </el-form-item>

            <div style="display: flex;">
                <el-switch style="display: inline-block;margin-top:7px;margin-right:30px" v-model="selectShort"
                    active-color="#13ce66" active-text="最短链路"
                    inactive-color="#ff4949" inactive-text="全部">
                </el-switch>
                <el-button style="display: inline-block;" type="primary" @click="submitForm('path')">查询</el-button>
                <el-button style="display: inline-block;" @click="resetForm('path')">重置</el-button>
            </div>
        </el-form>

        <div class="block" style="height:180px;margin-top:13px">            
        <!-- <div id="path-graph-container"  style="height:180px;border-radius:14px"> </div> -->
        <div v-if="showShortest" >
            <div  class="path-result">共{{shortestPath.length==0?0:1}}条路径</div>
            <el-timeline  :reverse="reverse">
                <el-timeline-item
                  v-for="(node, index) in shortestPath"
                    :key="index"
                    :color="node.color"
                    size="large"
                  >
                  <el-button round class="custom-button" type="primary" size="small"
                    v-bind:style="{ backgroundColor: node.color,borderColor:node.color }">{{node.label}}</el-button>
                    <span style="color:#fff !important;margin-left:10px;">{{node.name}}</span>
                  <!-- <el-button size="small" round plain>{{node.label}}</el-button>  {{node.name}} -->
                </el-timeline-item>
            </el-timeline>
        </div>

        <div v-if="showAllPath">
            <div class="path-result">共{{allPath.length}}条路径</div> 
            <el-timeline v-for="(path,index) in allPath" :key="index" :reverse="reverse">
                <el-timeline-item
                  v-for="(node, index) in path" :key="index" :color="node.color" size="large">
                  <el-button round class="custom-button" type="primary" size="small"
                    v-bind:style="{ backgroundColor: node.color,borderColor:node.color }">{{node.label}}</el-button>
                    <span style="color:#fff !important;margin-left:10px;">{{node.name}}</span>
                </el-timeline-item>
              </el-timeline>
        </div>

        </div>
    </div>
</template>

<script>

import G6, { Algorithm } from '@antv/g6'
const { findAllPath } = Algorithm;
const { findShortestPath } = Algorithm;

export default {
    data() {
        return {
            path:{
                "source":'',
                'target':''
            },
            selectShort:true,
            shortestPath:[],
            showShortest:false,
            showAllPath:false,
            reverse: false,
            shortestPath: [],
            allPath:[],
            pathNodeIcon:{
                "Website":"#9661BC","Person":"#F6903D","Company":"#5F95FF","Ip":"#61DDAA","Redirect":"#F08BB4"
            },
        } 
    },
    props:["graphData"],
    watch: {
        graphData: function(newVal, oldVal) {
        // 当 graphData 数据变化时执行渲染的逻辑
        }
    },
    methods: {
      submitForm(formName) {
        this.$refs[formName].validate((valid) => {
          if (valid) {
            if(this.selectShort){
                // this.findShortest(this.path.source,this.path.target);
                this.findShortestPath(this.graphData,this.path.source,this.path.target)
            }else{
                 this.findAllPaths(this.graphData,this.path.source,this.path.target);
            }
          } else {
            return false;
          }
        });
      },
      resetForm(formName){
        this.$refs[formName].resetFields();
        this.showAllPath=false;
        this.shortestPath=false;
      },
      findShortest(sname,tname){
        // var sname = "jone smith";
        // var tname = "192.168.1.50";
        this.axios({
            url:"api/graph/path/shortest",
            method:"get",
            params:{
                sname:sname,
                tname:tname
            }
        }).then(res=>{
            console.log(res.data)
            this.shortestPath = res.data;
            this.showPathGraph(res.data);
        })
      },
      showPathGraph(data){
        const containerId = "path-graph-container";
        const container = document.getElementById(containerId);
        const width = container.scrollWidth;
        const modHeight = 170; //TODO:容器高度
        const height = container.scrollHeight || modHeight;
        const backgroundColor = "#f0f0f0";
        container.style.backgroundColor = backgroundColor; //TODO:容器背景颜色
        const subjectColors = [
                    '#5F95FF', // blue
                    '#61DDAA',
                    '#65789B',
                    '#F6BD16',
                    '#7262FD',
                    '#78D3F8',
                    '#9661BC',
                    '#F6903D',
                    '#008685',
                    '#F08BB4',
        ];
        const backColor = backgroundColor;//节点底色
        const theme = 'default';
        const disableColor = '#777';
        const colorSets = G6.Util.getColorSetsBySubjectColors(
            subjectColors,
            backColor,
            theme,
            disableColor,
        );
        console.log(colorSets)
        
        //3、分类
        // var data = this.shortestPath;
        const clusterNode = ["Domain","Company","Person","Ip","Cert"];
        data.nodes.forEach(function (node) {
            const cid = clusterNode.indexOf(node.label);
            console.log(cid)
            console.log(colorSets[cid])
            if (!node.style) {
                node.style = {};
            }
            node.style.fill = colorSets[cid].mainStroke; //subjectColors
            node.style.stroke = colorSets[cid].mainStroke; //strokes[cid % strokes.length];
        });
        
        const clusterEdge = ["IS_SUB","FOUNDED_BY","HAS_IP","WORKS_FOR","HAS_CERT"];
        data.edges.forEach(edge => {
            const cid = clusterEdge.indexOf(edge.label);
            edge.style = {
                stroke: colorSets[cid].mainStroke,
            };
            edge.color = colorSets[cid].mainStroke;  //设置边的颜色
            edge.labelCfg={
                autoRotate: true,
                style: {
                    lineWidth: 4,
                    fill: colorSets[cid].mainStroke, //colorSets[i].mainStroke, //'#1890ff',  //文字颜色
                    fontSize: 14,
                    background: {
                        fill: colorSets[cid].mainFill, //colorSets[i].mainFill
                        stroke: colorSets[cid].mainStroke,
                        padding: [2, 2, 2, 2],
                        radius: 2,
                    },
                },
            };
        })

        const graph = new G6.Graph({
            container: containerId,
            data:data,
            width,
            height,
            layout: {
                type: 'force',
                linkDistance: 120, //边的长度 180
                preventOverlap: true,
                nodeStrength: -170,  //节点的引力，负数代表斥力
            },
            modes: {
                default: ['drag-canvas','zoom-canvas'],
            },
            defaultNode: {
                size: 20,
                icon: {
                    show: true,
                    img: 'https://gw.alipayobjects.com/zos/basement_prod/012bcf4f-423b-4922-8c24-32a89f8c41ce.svg',

                },
                labelCfg: {
                        /* label's position, options: center, top, bottom, left, right */
                            position: 'bottom',
                            /* label's offset to the keyShape, 4 by default */
                            //   offset: 12,
                            /* label's style */
                            //   style: {
                            //     fontSize: 20,
                            //     fill: '#ccc',
                            //     fontWeight: 500
                            //   }
                        },
            },
            animate: true,
        });

        graph.render();
        graph.on('node:dragstart', function (e) {
        graph.layout();
        refreshDragedNodePosition(e);
        });
        graph.on('node:drag', function (e) {
        const forceLayout = graph.get('layoutController').layoutMethods[0];
        forceLayout.execute();
        refreshDragedNodePosition(e);
        });
        graph.on('node:dragend', function (e) {
        e.item.get('model').fx = null;
        e.item.get('model').fy = null;
        });

        if (typeof window !== 'undefined')
        window.onresize = () => {
            if (!graph || graph.get('destroyed')) return;
            if (!container || !container.scrollWidth || !container.scrollHeight) return;
            graph.changeSize(container.scrollWidth, container.scrollHeight);
        };

        function refreshDragedNodePosition(e) {
        const model = e.item.get('model');
        model.fx = e.x;
        model.fy = e.y;
        }

      },
      findAllPaths(data,startId,endId){ //TODO:传入图数据
        this.showAllPath = true;
        this.showShortest = false;
        const allPath = findAllPath(data, startId, endId); //节点id
        // 期望输出值：[['A', 'D', 'F', 'E'], ['A', 'D', 'E'], ['A', 'E']]
        console.log(allPath);
        var resultList = []
        allPath.forEach(path=>{
            var result = path.map(id => {
                const node = data.nodes.find(n => n.id === id); //寻找对应的节点信息
                return { id: id, name: node.properties.name, label:node.label ,color:this.pathNodeIcon[node.label]};
            });
            resultList.push(result);
        })
        console.log(resultList)
        this.allPath = resultList
      },
      findShortestPath(data,startId,endId){
        // 不考虑边的方向性，查找节点 A 和 节点 C 之间的最短路径
        this.showShortest = true;
        this.showAllPath = false;
        const { length, path, allPath } = findShortestPath(data,startId,endId);
        console.log(length, path);// 期望输出：2, ['A', 'B', 'C']
        if(path==undefined){ //不存在路径 结果可能是undefined、Infinity
            console.log("no path")
            this.shortestPath = []
            console.log(this.shortestPath.length)
        }else{
            var result = path.map(id => {
                const node = data.nodes.find(n => n.id === id); //寻找对应的节点信息
                return { id: id, name: node.properties.name, label:node.label ,color:this.pathNodeIcon[node.label]};
            });
            console.log(result)
            this.shortestPath = result
        }
      }
    },
   
}
</script>

<style scoped>
    .path-result{
        font-size:14px;
        text-align: center;
        padding:5px;
        margin-bottom:15px;
        border:1px solid #ddd
    }
    .custom-button{
        color: #fff;font-size:12px;font-weight:700
    }

    /deep/ .el-input__inner{
        border: 1px solid #DCDFE6;
        height: 35px;
    
        /*border-radius: 24px;*/
    }

    /deep/.el-form-item__label {
        font-weight: 500;
    }


    /deep/.el-timeline {
        padding-left: 15px;
    }
</style>
