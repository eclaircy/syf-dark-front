<template>
    <div id="sankey-container" class="sankey-container"></div>
</template>

<script>
import { Sankey } from '@antv/g2plot';
import G6 from '@antv/g6';

export default {
    props:["graphData"],
    watch: {
        graphData: function(newVal, oldVal) {
        // 当 graphData 数据变化时执行渲染的逻辑
            this.show(this.graphData.edges);
            this.test(this.graphData)
        }
    },
    methods: {
        show(data){
            const DATA = [
            { source1: '首次打开', target: '首页 UV', value: 160 },
            { source1: '结果页', target: '首页 UV', value: 40 },
            { source1: '验证页', target: '首页 UV', value: 10 },
            { source1: '我的', target: '首页 UV', value: 10 },
            { source1: '朋友', target: '首页 UV', value: 8 },

            { source1: '其他来源', target: '首页 UV', value: 27 },
            { source1: '首页 UV', target: '理财', value: 30 },
            { source1: '首页 UV', target: '扫一扫', value: 40 },
            { source1: '首页 UV', target: '服务', value: 35 },
            
            { source1: '首页 UV', target: '蚂蚁森林', value: 25 },
            { source1: '首页 UV', target: '跳失', value: 10 },
            { source1: '首页 UV', target: '借呗', value: 30 },
            { source1: '首页 UV', target: '花呗', value: 40 },
            { source1: '首页 UV', target: '其他流向', value: 45 },
            ];
            console.log("sk")
            console.log(data)
            data.forEach(item => {
                item.value = 1;
            });
            const sankey = new Sankey('sankey-container', {
                data: data,
                // dataType:'node-link',
                sourceField: 'source',
                targetField: 'target',
                weightField: 'value',
                nodeWidthRatio: 0.018,
                nodePaddingRatio: 0.03,
                nodeState: {
                    active: {
                    style: {
                        linewidth: 1.5,
                    },
                    },
                },
                tooltip: { showTitle: true },
            });

            sankey.render();
            sankey.setState('active', (datum) => {
            return datum.isNode && datum.name === '首次打开';
            });
        },
        test(data){
            // 遍历边数据，计算节点的出度和入度权重和
    const nodeMap = new Map();
    data.edges.forEach(edge => {
      const { source, target, weight } = edge;
      // 统计出度权重和
      if (nodeMap.has(source)) {
        const nodeData = nodeMap.get(source);
        nodeData.outDegreeWeightSum += weight;
        nodeMap.set(source, nodeData);
      } else {
        nodeMap.set(source, { outDegreeWeightSum: weight, inDegreeWeightSum: 0 });
      }
      // 统计入度权重和
      if (nodeMap.has(target)) {
        const nodeData = nodeMap.get(target);
        nodeData.inDegreeWeightSum += weight;
        nodeMap.set(target, nodeData);
      } else {
        nodeMap.set(target, { outDegreeWeightSum: 0, inDegreeWeightSum: weight });
      }
    });
    console.log(nodeMap)

        }
    },
    mounted(){
        // this.show()
    }
}
</script>

<style scoped>
    .sankey-container{
        height:300px
    }
</style>