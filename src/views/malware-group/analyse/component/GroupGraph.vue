<template>
    <div style="height:400px;width:760px">
        <i class="el-icon-full-screen" @click="toggleFullScreen"></i>
        <div id="group-graph" ref="graph" class="group-graph"> </div>
    </div>
    
</template>

<style scoped>
.group-graph{
    display:flex;
    scrollWidth:760px; 
    scrollHeight:400px;
}

.el-icon-full-screen{
    right: 20px;
    top: 20px;
    cursor: pointer;
}
</style>
<script>
import insertCss from 'insert-css';
import G6 from '@antv/g6';
import screenfull from 'screenfull';
import { P } from '@antv/g2plot';
export default {
    props:["graphData","cid"],

    data(){
        return{
           
        }
    },

    watch: {
        graphData: function(newVal, oldVal) {
        // 当 graphData 数据变化时执行渲染的逻辑
            this.show();
        }
    },
    methods: {
        show(){
            var data = this.graphData
            const containerId = "group-graph"
            const graphDiv = document.getElementById(containerId);
            const container = document.getElementById(containerId);
            const width = container.scrollWidth ||760;
            const height = container.scrollHeight ||400; //TODO:原本为450，这里修改画布的高度
            
            const canvasBackgroundColor = '#363B40';
            const darkBackColor = '#2B384E'; //TODO:这里修改节点的背景颜色 原本rgb(43, 47, 51)
            container.style.backgroundColor = canvasBackgroundColor; //TODO:背景颜色?
            const nodeSize =30;
            const nodeIconSize =30;
            const linkDistance = 130; //边的长度
            const nodeStrength = -20; //节点斥力
            const realEdgeOpacity = 0.4; //
            const lineWidth = 1.3;
            const clusterNode = ["Website","Company","Person","Ip","Redirect"];
            const clusterEdge = ["BELONGS_TO","DOWNLOAD_FROM","HAS_IP","HAS_COMPANY","SIMILAR_TO"];
            const subjectColors = [
                '#5F95FF', // blue
                '#61DDAA', //green
                '#65789B', //grey
                '#F6BD16', //yellow
                '#9661BC', //purple
                '#7262FD',//purple
                '#78D3F8',
                '#F6903D',
                '#008685',
                '#F08BB4',
                '#65789B', //grey
            ];
            const backColor = '#fff';//TODO:'#fff'
            const theme = 'dark';
            const disableColor = '#777';
            const colorSets = G6.Util.getColorSetsBySubjectColors(
                subjectColors,
                darkBackColor,
                // backColor,
                theme,
                disableColor,
            );

            // define the CSS with the id of your menu
            insertCss(`
                .g6-component-contextmenu {
                position: absolute;
                z-index: 2;
                list-style-type: none;
                background-color: #363b40; 
                border-radius: 6px;
                font-size: 14px;
                color: hsla(0,0%,100%,.85);
                width: fit-content;
                transition: opacity .2s;
                text-align: center;
                padding: 0px 20px 0px 20px;
                    box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.6);
                    border: 0px;
            }
            .g6-component-contextmenu ul {
                    padding-left: 0px;
                    margin: 0;
            }
            .g6-component-contextmenu li {
                cursor: pointer;
                list-style-type: none;
                list-style: none;
                margin-left: 0;
                line-height: 38px;
            }
            .g6-component-contextmenu li:hover {
                color: #aaaaaa;
                }
            `);

            //3、分类
            const clusterNodeIcon = {

            }

           
            data.nodes.forEach(function (node) {
                const cid = clusterNode.indexOf(node.label);
                node.legendType=node.label;
                if (!node.style) {
                    node.style = {};
                }
                node.icon = {
                    show:true,
                    img:require("@/assets/nodes/"+node.label+".png"),
                }
                node.style.fill = "#2B384E";
                node.style.stroke = "#2B384E";
            });

            data.edges.forEach(edge => {
                const cid = clusterEdge.indexOf(edge.label);
                edge.legendType=edge.label;
                edge.label=null;
                //4.20新增
                edge.color = colorSets[cid].mainStroke;  //设置边的颜色
                edge.style = {
                    stroke: colorSets[cid].mainStroke,
                    endArrow:{
                        path: G6.Arrow.triangle(),
                        fill:colorSets[cid].mainStroke,
                    },
                };
            })

            var legendConfig = {}; 
            const nodeLegendSize = 15;
            var legendData = {}
            legendData.nodes = [];
            legendData.edges = [];
            var filterFunctions = {};
            clusterNode.forEach(element => {
                const cid = clusterNode.indexOf(element);
                var nodeLegendConfig = {};
                nodeLegendConfig["r"]=nodeLegendSize; //图例节点的大小
                nodeLegendConfig["style"] = {
                    "fill":colorSets[cid].mainStroke,
                    "stroke":colorSets[cid].mainStroke //设置这个，不然node的边框会变成蓝色
                };
                legendConfig[element]=nodeLegendConfig;

                legendData.nodes.push({
                    id:element,
                    label:element,
                    ...legendConfig[element]
                })
                filterFunctions[element] = (d)=>{if (d.legendType === element) return true;return false}
            });

            clusterEdge.forEach(element=>{
                const cid = clusterEdge.indexOf(element);
                var edgeLegendConfig = {};
                edgeLegendConfig["type"]="line"; //图例节点的大小
                edgeLegendConfig["style"]={"stroke":colorSets[cid].mainStroke,"width":20};
                legendConfig[element]=edgeLegendConfig;

                legendData.edges.push({
                    id: element,
                    label: element,
                    ...legendConfig[element]
                })
                filterFunctions[element] = (d)=>{if (d.legendType === element) return true;return false}
            })
            console.log(filterFunctions)

            // Custom super node
            G6.registerNode(
            'aggregated-node',
            {
                draw(cfg, group) {
                let width = 53,
                    height = 27;
                const style = cfg.style || {};
                const colorSet = cfg.colorSet || colorSets[0];

                // halo for hover
                group.addShape('rect', {
                    attrs: {
                    x: -width * 0.55,
                    y: -height * 0.6,
                    width: width * 1.1,
                    height: height * 1.2,
                    fill: colorSet.mainFill,
                    opacity: 0.9,
                    lineWidth: 0,
                    radius: (height / 2 || 13) * 1.2,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'halo-shape',
                    visible: false,
                });

                // focus stroke for hover
                group.addShape('rect', {
                    attrs: {
                    x: -width * 0.55,
                    y: -height * 0.6,
                    width: width * 1.1,
                    height: height * 1.2,
                    fill: colorSet.mainFill, // '#3B4043',
                    stroke: '#AAB7C4',
                    lineWidth: 1,
                    lineOpacty: 0.85,
                    radius: (height / 2 || 13) * 1.2,
                    },
                    name: 'stroke-shape',
                    visible: false,
                });

                const keyShape = group.addShape('rect', {
                    attrs: {
                        ...style,
                        x: -width / 2,
                        y: -height / 2,
                        width,
                        height,
                        fill: colorSet.mainFill, // || '#3B4043',
                        stroke: colorSet.mainStroke,
                        lineWidth: 2,
                        cursor: 'pointer',
                        radius: height / 2 || 13,
                        lineDash: [2, 2],
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'aggregated-node-keyShape',
                });

                let labelStyle = {};
                if (cfg.labelCfg) {
                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);
                }
                group.addShape('text', {
                    attrs: {
                        text: `${cfg.count}`,
                        x: 0,
                        y: 0,
                        textAlign: 'center',
                        textBaseline: 'middle',
                        cursor: 'pointer',
                        fontSize: 12,
                        fill: '#fff',
                        opacity: 0.85,
                        fontWeight: 400,
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'count-shape',
                    className: 'count-shape',
                    draggable: true,
                });

                // tag for new node
                if (cfg.new) {
                    group.addShape('circle', {
                    attrs: {
                        x: width / 2 - 3,
                        y: -height / 2 + 3,
                        r: 4,
                        fill: '#6DD400',
                        lineWidth: 0.2,
                        stroke: '#FFFFFF',
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: 'typeNode-tag-circle',
                    });
                }
                return keyShape;
                },
                setState: (name, value, item) => {
                const group = item.get('group');
                if (name === 'layoutEnd' && value) {
                    const labelShape = group.find((e) => e.get('name') === 'text-shape');
                    if (labelShape) labelShape.set('visible', true);
                } else if (name === 'hover') {
                    if (item.hasState('focus')) {
                    return;
                    }
                    const halo = group.find((e) => e.get('name') === 'halo-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    halo && halo.show();
                    keyShape.attr('fill', colorSet.activeFill);
                    } else {
                    halo && halo.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                } else if (name === 'focus') {
                    const stroke = group.find((e) => e.get('name') === 'stroke-shape');
                    const keyShape = item.getKeyShape();
                    const colorSet = item.getModel().colorSet || colorSets[0];
                    if (value) {
                    stroke && stroke.show();
                    keyShape.attr('fill', colorSet.selectedFill);
                    } else {
                    stroke && stroke.hide();
                    keyShape.attr('fill', colorSet.mainFill);
                    }
                }
                },
                update: undefined,
            },
            'single-node',
            );

            const cnode = {
                id: "c",
                count:"团伙"+this.cid,
                label:"团伙", //+this.cid,
                type: 'aggregated-node',
                level: 1,
            };
            data.nodes.forEach(function (node) {
                //添加每个节点到Cluster节点的边
                if(node.label=="Website"){
                    data.edges.push({
                        source:"c",
                        target:node.id,
                        id:"c-"+node.id,
                        stroke: '#acaeaf',
                        opacity:0.5,
                        endArrow:false,
                        lineWidth:0.2,
                    })
                }
            })
            data.nodes.push(cnode)

            // const legend = new G6.Legend({
            //     data: legendData,
            //     align: 'center',
            //     layout: 'vertical', // vertical  图标水平或竖直  horizontal
            //     position: 'bottom-left',  //TODO: 图标的位置原本为bottom-left
            //     vertiSep: 10, //12竖直间距
            //     horiSep: 20, //图例间的水平间距
            //     offsetX: 10, //图例区域离 position 对应的默认位置的 x 方向的偏移量，可被用于图例位置的微调
            //     offsetY: -10,
            //     padding: [12, 4, 8, 16], //图例区域内部内容到边框的距离，四位数组分别代表上、右、下、左边距
            //     containerStyle: {
            //         fill: '#ccc',
            //         lineWidth: 1
            //     },
            //     title: '',
            //     titleConfig: {
            //         position: 'center',
            //         offsetX: 0,
            //         offsetY: 12,
            //     },
            //     filter: {
            //         enable: true,
            //         trigger: 'mouseenter',
            //         graphActiveState: 'activeByLegend',
            //         graphInactiveState: 'inactiveByLegend',
            //         filterFunctions: filterFunctions
            //     }
            // });

            //tooltip 悬浮提示框
            const tooltip = new G6.Tooltip({
                offsetX: 10,
                offsetY: 10,
                // the types of items that allow the tooltip show up
                // 允许出现 tooltip 的 item 类型
                itemTypes: ['node', 'edge'],
                // custom the tooltip's content
                // 自定义 tooltip 内容
                getContent: (e) => {
                    const outDiv = document.createElement('div');
                    outDiv.style.width = 'fit-content';
                    //outDiv.style.padding = '0px 0px 20px 0px';
                    // <ul>
                    //     <li>节点类型:${e.item.getType()}</li>
                    // </ul>
                    if(e.item.getType()=="node"){
                        outDiv.innerHTML = `
                        <h4>节点信息</h4>
                        <ul>
                            <li>节点id:<button style="font-weight: bold;"> ${e.item.getModel().id}</button></li>
                        </ul>
                        <ul>
                            <li>节点类型:<button style="font-weight: bold;"> ${e.item.getModel().label}</button></li>
                        </ul>
                        <ul>
                            <li>节点名称: ${e.item.getModel().properties["name"] || e.item.getModel().id}</li>
                        </ul>
                    `;
                    }
                    return outDiv;
                },
            });

            let hiddenItemIds = []; // 隐藏的元素 id 数组
            let expandArray = [];
            let collapseArray = [];
            let newAddArray = [];
            const hideItems = (graph) => {
                hiddenItemIds.forEach((id) => {
                    graph.hideItem(id);
                });
            };

            const showItems = (graph) => {
                graph.getNodes().forEach((node) => {
                    if (!node.isVisible()) graph.showItem(node);
                });
                graph.getEdges().forEach((edge) => {
                    if (!edge.isVisible()) edge.showItem(edge);
                });
                hiddenItemIds = [];
            };

            const findNeighbors = (graph,model,depth=1) =>{
                fetch("api/graph/domain?dname="+model.properties.name+"&depth="+depth)
                .then((res) => res.json())
                .then((data) => {
                    data.nodes.forEach((node)=>{
                        if(!graph.findById(node.id)){
                            newAddArray.push(node.id);
                            console.log("not find",node.id)
                            node.legendType=node.label;
                            if (!node.style) {
                                node.style = {};
                            }
                            node.icon = {
                                show:true,
                                img:require("@/assets/nodes/"+node.label+".png"),
                                // img:require("@/assets/nodes/Redirect.png"),
                            }
                            node.style.fill = "#2B384E";
                            node.style.stroke = "#2B384E";
                            console.log("add",node.id)
                            graph.addItem('node',node );
                        }
                    })
                    data.edges.forEach((edge)=>{
                        edge.label=null;
                        const rs = graph.find("edge",(oedge)=>{
                            return oedge.get('model').source==edge.source&& oedge.get('model').target==edge.target;
                        })
                        console.log(rs)
                        if(!rs){
                            edge.id = 'edge' + edge.id;
                            graph.addItem('edge',edge );
                        }
                        // 
                    })
                    
                })
            }
                //菜单 
            const contextMenu = new G6.Menu({
                shouldBegin(evt) {
                    if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) return true;
                    if (evt.item) return true;
                    return false;
                },
                getContent(evt) {
                    const { item } = evt;
                    let header;
                    if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) { //右键画布
                        return `<ul>
                        <li id='show'>显示全部隐藏节点</li>
                        <li id='collapseAll'>Collapse all Clusters</li>
                        </ul>`;
                    } 
                    else if (!item) return;
                    const itemType = item.getType();
                    const model = item.getModel();
                    if (itemType && model) {
                        if (itemType == 'node') { //右键节点
                            return `
                                <ul>
                                    <li id='expand'>展开一度关联节点</li>
                                    <li id='expand2'>展开二度关联节点</li>
                                    <li id='hideNeighbor'>折叠关联节点</li>
                                    <li id='hide'>隐藏节点</li>
                                </ul>`;
                        }
                    }
                },
                handleMenuClick: (target, item) => {
                    const model = item && item.getModel();
                    const liIdStrs = target.id.split('-');
                    let mixedGraphData;
                    switch (liIdStrs[0]) {
                    case 'hide':
                        graph.hideItem(item);
                        hiddenItemIds.push(model.id);
                        break;
                    case 'expand':
                        findNeighbors(graph,model)
                        break;
                    case 'expand2':
                        findNeighbors(graph,model,2)
                            break;
                    case 'collapse':
                        const aggregatedNode = aggregatedNodeMap[model.clusterId];
                        manipulatePosition = { x: aggregatedNode.x, y: aggregatedNode.y };
                        collapseArray.push(aggregatedNode);
                        for (let i = 0; i < expandArray.length; i++) {
                            if (expandArray[i].id === model.clusterId) {
                                expandArray.splice(i, 1);
                                break;
                            }
                        }
                        mixedGraphData = getMixedGraph(
                            clusteredData,
                            data,
                            nodeMap,
                            aggregatedNodeMap,
                            expandArray,
                            collapseArray,
                        );
                        break;
                    case 'collapseAll':
                        newAddArray.forEach(id=>{
                            graph.hideItem(id)
                        });
                        break;
                    case 'neighbor':
                        const expandNeighborSteps = parseInt(liIdStrs[1]);
                        mixedGraphData = getNeighborMixedGraph(
                            model,
                            expandNeighborSteps,
                            data,
                            clusteredData,
                            currentUnproccessedData,
                            nodeMap,
                            aggregatedNodeMap,
                            10,
                        );
                        break;
                    case 'hideNeighbor':
                        const node = graph.findById(model.id);
                        const neightborList = node.getNeighbors()
                        neightborList.forEach(element=>{
                            const id = element.getModel().id
                            graph.hideItem(id)
                            hiddenItemIds.push(id); //将邻居节点id加入隐藏数组
                        })
                        //隐藏节点本身
                        graph.hideItem(item);
                        hiddenItemIds.push(model.id);
                        break;
                    case 'show':
                        showItems(graph);
                        break;
                    default:
                        break;
                    }
                    if (mixedGraphData) {
                        cachePositions = cacheNodePositions(graph.getNodes());
                        currentUnproccessedData = mixedGraphData;
                        handleRefreshGraph(
                            graph,
                            currentUnproccessedData,
                            CANVAS_WIDTH,
                            CANVAS_HEIGHT,
                            largeGraphMode,
                            true,
                            false,
                        );
                    }
            },
                // offsetX and offsetY include the padding of the parent container
                // 需要加上父级容器的 padding-left 16 与自身偏移量 10
                offsetX: 16 + 10,
                // 需要加上父级容器的 padding-top 24 、画布兄弟元素高度、与自身偏移量 10
                offsetY: 0,
                // the types of items that allow the menu show up
                // 在哪些类型的元素上响应
                itemTypes: ['node', 'edge', 'canvas'],
            });

            const graph = new G6.Graph({
                container: containerId,
                width,   
                height,
                // fitView:true, 别开最好
                //TODO:注意 fitCenter和layout中的center只选择一个
                // fitCenter: true,
                // linkCenter: true,
                modes: {
                    // default: ['drag-canvas', 'activate-relations', 'zoom-canvas']
                    default: ['drag-canvas', 'zoom-canvas']
                    // default: ['drag-node'],
                },
                layout: {
                    type: 'force',
                    linkDistance: 90, //边的长度 180
                    preventOverlap: true,
                    // nodeStrength: nodeStrength,  //节点的引力，负数代表斥力
                    center: [width / 2, height / 2],// 可选，默认为图的中心
                    nodeStrength: (d) => {
                    if (d.isLeaf) {
                        return -450;
                    }
                    return -390;
                    },
                },
                defaultNode: {
                    size: nodeSize,
                    type: 'circle',
                    style: {
                        lineWidth: 2,
                    },
                    labelCfg: {
                        position: 'bottom',
                        style: {
                            fill: '#FFF',
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            fill: '#2B384E',
                        },
                    },
                    // labelCfg: {} ,
                    icon: {
                        show: true,
                        // img: 'https://gw.alipayobjects.com/zos/basement_prod/012bcf4f-423b-4922-8c24-32a89f8c41ce.svg',
                        /* icon's size, 20 * 20 by default: */
                        // img:require("@/assets/nodes/person.png"),
                            width: nodeIconSize,
                            height: nodeIconSize
                    },
                },
                defaultEdge: {
                    color:"#D8D8D8",
                    style:{  //TODO:可以修改箭头的样式  https://g6.antv.antgroup.com/manual/middle/elements/edges/arrow
                        // stroke:"#D8D8D8",
                        // endArrow:{
                            // path: G6.Arrow.triangle(),
                            // fill:'#D8D8D8',
                        // },
                        // stroke: '#acaeaf',
                        // realEdgeStroke: '#acaeaf', //'#f00',
                        endArrow:true,
                        realEdgeOpacity,
                        strokeOpacity: realEdgeOpacity,
                        lineWidth:lineWidth,
                    },
                    labelCfg: {
                        style: {
                            fill: '#acaeaf',
                            realEdgeStroke: '#acaeaf', //'#f00',
                            realEdgeOpacity: 0.5,
                            stroke: '#191b1c',
                        },
                    },
                    stateStyles: {
                        focus: {
                            stroke: '#fff', // '#3C9AE8',
                        },
                    },
                },
                nodeStateStyles: {
                    activeByLegend: {
                        lineWidth: 10,
                        strokeOpacity: 0.5
                    },
                    inactiveByLegend: {
                        
                    },
                    active: {
                        lineWidth: 10,
                        strokeOpacity: 0.5,
                    },
                    inactive:{ //必须设置这个，否则node样式会变化
                        fill:"#2B384E",
                        stroke:"#2B384E"
                    }
                },
                edgeStateStyles: {
                    activeByLegend: {
                        lineWidth: 3
                    },
                    inactiveByLegend: {
                        opacity: 0.5
                    },
                    inactive:{

                    }
                },
                animate: true,
                plugins: [tooltip,contextMenu],
            });

            graph.data({
                nodes: data.nodes,
                edges: data.edges.map(function (edge, i) {
                    // edge.id = 'edge' + i;
                    edge.id = 'edge' + edge.id;
                    return Object.assign({}, edge);
                }),
            });


            graph.render();

            graph.on('node:dragstart', function (e) {
                graph.layout();
                refreshDragedNodePosition(e);
            });
            graph.on('node:drag', function (e) {
                const forceLayout = graph.get('layoutController').layoutMethods[0];
                forceLayout.execute();
                refreshDragedNodePosition(e);
            });
            graph.on('node:dragend', function (e) {
                e.item.get('model').fx = null;
                e.item.get('model').fy = null;
            });

            graph.on('afteradditem',function (e) {
                console.log("after add回调函数")
                graph.layout();
                refreshDragedNodePosition(e);
            });

            graph.on('node:mouseenter', (evt) => {
                const { item } = evt;
                graph.setItemState(item, 'active', true);
                const neighbors = graph.getNeighbors(item); // 获取节点的邻居节点数组
                neighbors.forEach((neighbor) => {
                    graph.setItemState(neighbor, 'active', true);
                });
            });

            graph.on('node:mouseleave', (evt) => {
                const { item } = evt;
                graph.setItemState(item, 'active', false);
                const neighbors = graph.getNeighbors(item); // 获取节点的邻居节点数组
                neighbors.forEach((neighbor) => {
                    graph.setItemState(neighbor, 'active', false);
                });
            });


            if (typeof window !== 'undefined')
            window.onresize = () => {
                if (!graph || graph.get('destroyed')) return;
                if (!container || !container.scrollWidth || !container.scrollHeight) return;
                graph.changeSize(container.scrollWidth, container.scrollHeight);
            };

            function refreshDragedNodePosition(e) {
                const model = e.item.get('model');
                model.fx = e.x;
                model.fy = e.y;
            }
        },
        toggleFullScreen() {
            if (screenfull.isEnabled) {
                screenfull.toggle(this.$refs.graph);
            }
        },
        exportCsv(){
            // 获取G6图谱数据
            const data = this.graphCanvas.getNodes();
            let csvContent = '';
            csvContent += 'id,label,name,\n'; // 表头
            data.forEach((node) => {
                var node = node.getModel();
                csvContent += `${node.id},${node.legendType},${node.properties.name}\n`; // 表格内容
            });
            // 创建Blob对象并下载文件
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
            saveAs(blob, '团伙成员.csv');
        }
    },
    mounted(){
    //    
    },

}
</script>