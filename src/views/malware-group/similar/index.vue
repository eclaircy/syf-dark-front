<template>
    <div style="padding:20px;">
        <el-row>
            <el-card>
                 <div style="font-size: 20px;margin-bottom: 7px;">网站同源性分析</div>
                 <span>根据网站相似度分析同源性</span>
            </el-card>
        </el-row>
        <el-row>
            <el-card>
                <el-row style="margin-bottom:0px;">
                    <el-col :span="10">
                        <!-- <div class="search-wrapper">
                            <div class="input-holder">
                                <input type="text" class="search-input" placeholder="Type url to search Website" v-model="input"/>
                                <button class="search-icon" @click="searchWebsite"><span></span></button>
                            </div>
                        </div>   -->

                        <el-input placeholder="Type URL to search websites" v-model="input" class="input" clearable style="width:300px;margin-top:20px;margin-left: 20px;">
                            <el-button slot="append" icon="el-icon-search" @click="searchWebsite()" ></el-button>
                        </el-input>
                    </el-col>
                    <el-col :span="7">
                        网站相似度阈值
                        <div style="margin-left:20px;margin-right:20px;">
                            <el-slider :min="50" :max="100" :step="10" v-model="value" range :show-tooltip="true" :marks="marks" :disabled="disabled"></el-slider>
                        </div>      
                    </el-col>
                    <el-col :span="4">
                        <div>
                            <el-switch v-model="showSimilarity"  active-text="显示相似度" inactive-text="" inactive-color="#ff4949"></el-switch>
                        </div>
                        <div style="margin-top:15px;">
                            <el-switch v-model="showSiteName"  active-text="显示网站名称" inactive-text="" inactive-color="#ff4949"></el-switch>
                        </div>
                    </el-col>
                    <el-col :span="3">
                        <el-button type="primary" @click="exportGraph">导出图片</el-button>
                        <!-- <el-button @click="exportCsv">导出csv</el-button> -->
                    </el-col>
                </el-row>
            </el-card>
        </el-row>

        <el-row>
            <el-card style="display: flex;justify-content: center;">
                <div id="similar-graph" class="similar-graph"></div>
            </el-card>
            
        </el-row>
    </div>
</template>

<script>
import G6 from '@antv/g6';
import insertCss from 'insert-css';
import { saveAs } from 'file-saver';
export default {
    data() {
        return {
            input:'',
            searchData:'',
            graphData:'',
            graphCanvas:undefined,
            showSimilarity:false,
            showSiteName:false,
            value: [50, 100],
            marks: {
                50: "50%",
                100: "100%",
            },
            disabled: false,
        }
    },
    watch:{
        showSimilarity(newVal,oldVal){
            if(this.graphCanvas!=undefined){
                this.showSimilar(newVal)
            }
        },
        showSiteName(newVal,oldVal){
            if(this.graphCanvas!=undefined){
                this.showSitesName(newVal)
            }
        },
        value(newVal,oldVal){
            if(this.graphCanvas!=undefined){
                this.filterSimilarity(newVal[0]/100,newVal[1]/100)
            }
        }
    },
    methods: {                        
        showSomeSimilar(){
            var limit = 150;
            this.axios({
                url:"api/graph/similar/some?limit="+limit,
                method:'get'
            }).then(res=>{
                this.graphData=res.data;
                // console.log(res.data.edges)
                this.showGraph(this.graphData)
            })
        },
        showGraph(data){ //TODO:设置画布的约束范围；
            const containerId = "similar-graph"
            const container = document.getElementById(containerId);
            const width = 1000;
            const height = 600; 
            const constrainBox = { x: 10, y: 10, width: width-30, height: height-30 };
            // const backrect = document.createElement('div');
            // backrect.style.backgroundColor = '#666';
            // backrect.style.opacity = 0.1;
            // backrect.style.marginLeft = `${constrainBox.x}px`;
            // backrect.style.marginTop = `${constrainBox.y}px`;
            // backrect.style.width = `${constrainBox.width}px`;
            // backrect.style.height = `${constrainBox.height}px`;
            // backrect.style.position = 'absolute';
            // container.appendChild(backrect);
            const canvasBackgroundColor = '#363B40';
            const darkBackColor = '#2B384E';
            container.style.backgroundColor = canvasBackgroundColor; 
            const linkDistance = 60;
            const nodeSize = 25;
            const nodeIconSize = 25;
            const realEdgeOpacity = 0.4;
            insertCss(`
            .g6-component-tooltip {
                background-color: rgba(255, 255, 255, 0.8);
                padding: 0px 10px 24px 10px;
                box-shadow: rgb(174, 174, 174) 0px 0px 10px;
            }
            .g6-component-contextmenu {
                position: absolute;
                z-index: 2;
                list-style-type: none;
                background-color: #363b40; 
                border-radius: 6px;
                font-size: 14px;
                color: hsla(0,0%,100%,.85);
                width: fit-content;
                transition: opacity .2s;
                text-align: center;
                padding: 0px 20px 0px 20px;
                    box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.6);
                    border: 0px;
            }
            .g6-component-contextmenu ul {
                    padding-left: 0px;
                    margin: 0;
            }
            .g6-component-contextmenu li {
                cursor: pointer;
                list-style-type: none;
                list-style: none;
                margin-left: 0;
                line-height: 38px;
            }
            .g6-component-contextmenu li:hover {
                color: #aaaaaa;
                }
            .g6-component-toolbar li {
                list-style-type: none !important;
            }
            `);
            const subjectColors = [
                '#5F95FF', // blue
                '#61DDAA',
                '#65789B',
                '#F6BD16',
                '#9661BC', //purple
                '#78D3F8',
                '#9661BC',
                '#F6903D',
                '#008685',
                '#F08BB4',
            ];
            const backColor = '#fff';//
            const theme = 'default';
            const disableColor = '#777';
            const colorSets = G6.Util.getColorSetsBySubjectColors(
                subjectColors,
                backColor,
                theme,
                disableColor,
            );

            const onTick = () => {
                let minx = 99999999;
                let maxx = -99999999;
                let miny = 99999999;
                let maxy = -99999999;
                let maxsize = -9999999;
                data.nodes.forEach((node) => {
                    if (minx > node.x) {
                    minx = node.x;
                    }
                    if (maxx < node.x) {
                    maxx = node.x;
                    }
                    if (miny > node.y) {
                    miny = node.y;
                    }
                    if (maxy < node.y) {
                    maxy = node.y;
                    }
                    if (maxsize < node.size) {
                    maxsize = node.size;
                    }
                });
                const scalex = (constrainBox.width - maxsize) / (maxx - minx);
                const scaley = (constrainBox.height - maxsize) / (maxy - miny);
                data.nodes.forEach((node) => {
                    node.x = (node.x - minx) * scalex + constrainBox.x;
                    node.y = (node.y - miny) * scaley + constrainBox.y;
                });
            };

            // this.showSanky(data.edges);

            //3、分类
            const clusterNode = ["Website"];
            const clusterEdge = ["SIMILAR_TO"];
            data.nodes.forEach(function (node) {
                const cid = clusterNode.indexOf(node.label);
                node.legendType=node.label;
                if (!node.style) {
                    node.style = {};
                }
                node.icon = {
                    show:true,
                    img:require("@/assets/nodes/"+node.label+".png"),
                };
                node.label=null;
                node.style.fill = "#2B384E";   //colorSets[cid].mainStroke; 
                node.style.stroke = "#2B384E";//colorSets[cid].mainStroke; 
            });
            data.edges.forEach(edge => {
                const cid = clusterEdge.indexOf(edge.label);
                edge.legendType=edge.label;
                edge.label=null;
                // edge.label=edge.properties.similarity.toFixed(2);
                edge.style = {
                    stroke: colorSets[cid].mainStroke,
                    endArrow:{
                        path: G6.Arrow.triangle(),
                        fill:colorSets[cid].mainStroke,
                    },
                };
                edge.color = colorSets[cid].mainStroke;  //设置边的颜色
                edge.labelCfg={
                    autoRotate: true,
                    style: {
                        lineWidth: 4,
                        fill: "#fff", // colorSets[cid].mainStroke, //'#1890ff',  //文字颜色
                        fontSize: 10, //标签文字大小：原来14px
                        // background: {
                        //     fill: "#2B384E",//colorSets[cid].mainFill, //标签背景颜色
                        //     stroke: colorSets[cid].mainStroke,  //colorSets[cid].mainStroke 标签边框
                        //     padding: [2, 2, 2, 2],
                        //     radius: 2,
                        // },
                    },
                };
            })

            var legendConfig = {}; 
            const nodeLegendSize = 15;
            var legendData = {}
            legendData.nodes = [];
            legendData.edges = [];
            var filterFunctions = {};
            clusterNode.forEach(element => {
                const cid = clusterNode.indexOf(element);
                var nodeLegendConfig = {};
                nodeLegendConfig["r"]=nodeLegendSize; //图例节点的大小
                nodeLegendConfig["style"] = {
                    "fill":colorSets[cid].mainStroke,
                    "stroke":colorSets[cid].mainStroke //设置这个，不然node的边框会变成蓝色
                };
                legendConfig[element]=nodeLegendConfig;

                legendData.nodes.push({
                    id:element,
                    label:element,
                    ...legendConfig[element]
                })
                filterFunctions[element] = (d)=>{if (d.legendType === element) return true;return false}
            });

            clusterEdge.forEach(element=>{
                const cid = clusterEdge.indexOf(element);
                var edgeLegendConfig = {};
                edgeLegendConfig["type"]="line"; //图例节点的大小
                edgeLegendConfig["style"]={"stroke":colorSets[cid].mainStroke,"width":20};
                legendConfig[element]=edgeLegendConfig;

                legendData.edges.push({
                    id: element,
                    label: element,
                    ...legendConfig[element]
                })
                filterFunctions[element] = (d)=>{if (d.legendType === element) return true;return false}
            })
            console.log(filterFunctions)
            const legend = new G6.Legend({
                data: legendData,
                align: 'center',
                layout: 'vertical', // vertical  图标水平或竖直  horizontal
                position: 'bottom-left',  //TODO: 图标的位置原本为bottom-left
                vertiSep: 10, //12竖直间距
                horiSep: 20, //图例间的水平间距
                offsetX: 10, //图例区域离 position 对应的默认位置的 x 方向的偏移量，可被用于图例位置的微调
                offsetY: -10,
                padding: [12, 4, 8, 16], //图例区域内部内容到边框的距离，四位数组分别代表上、右、下、左边距
                containerStyle: {
                    fill: '#ccc',
                    lineWidth: 1
                },
                title: '',
                titleConfig: {
                    position: 'center',
                    offsetX: 0,
                    offsetY: 12,
                },
                filter: {
                    enable: true,
                    trigger: 'mouseenter',
                    graphActiveState: 'activeByLegend',
                    graphInactiveState: 'inactiveByLegend',
                    filterFunctions: filterFunctions
                }
            });

            //tooltip 悬浮提示框
            const tooltip = new G6.Tooltip({
                offsetX: 10,
                offsetY: 10,
                // the types of items that allow the tooltip show up
                // 允许出现 tooltip 的 item 类型
                itemTypes: ['node', 'edge'],
                // custom the tooltip's content
                // 自定义 tooltip 内容
                getContent: (e) => {
                    const outDiv = document.createElement('div');
                    outDiv.style.width = 'fit-content';
                    //outDiv.style.padding = '0px 0px 20px 0px';
                    // <ul>
                    //     <li>节点类型:${e.item.getType()}</li>
                    // </ul>
                    if(e.item.getType()=="node"){
                        outDiv.innerHTML = `
                        <h4>节点信息</h4>
                        <ul>
                            <li>节点类型:<button style="font-weight: bold;"> ${e.item.getModel().label}</button></li>
                        </ul>
                        <ul>
                            <li>节点名称: ${e.item.getModel().properties["name"] || e.item.getModel().id}</li>
                        </ul>
                        <ul>
                            <li>PageRank: ${result[e.item.getModel().id]}</li>
                        </ul>
                    `;
                    }
                    else if(e.item.getType()=="edge"){
                        outDiv.innerHTML = `
                            <ul>
                                <li>相似度:<button style="font-weight: bold;"> ${e.item.getModel().properties.similarity}</button></li>
                            </ul>
                        `;
                    }
                    return outDiv;
                },
            });
            let hiddenItemIds = []; // 隐藏的元素 id 数组
            let expandArray = [];
            let collapseArray = [];
            let newAddArray = [];
            const hideItems = (graph) => {
                hiddenItemIds.forEach((id) => {
                    graph.hideItem(id);
                });
            };

            const showItems = (graph) => {
                graph.getNodes().forEach((node) => {
                    if (!node.isVisible()) graph.showItem(node);
                });
                graph.getEdges().forEach((edge) => {
                    if (!edge.isVisible()) edge.showItem(edge);
                });
                hiddenItemIds = [];
            };

            const findNeighbors = (graph,model,depth=1) =>{
                fetch("api/graph/domain?dname="+model.properties.name+"&depth="+depth)
                .then((res) => res.json())
                .then((data) => {
                    var newNodeCount = 0;
                    var newEdgeCount = 0;
                    data.nodes.forEach((node)=>{
                        if(!graph.findById(node.id)){
                            newNodeCount+=1;
                            newAddArray.push(node.id);
                            console.log("not find",node.id)
                            node.legendType=node.label;
                            if (!node.style) {
                                node.style = {};
                            }
                            node.icon = {
                                show:true,
                                img:require("@/assets/nodes/"+node.label+".png"),
                                // img:require("@/assets/nodes/Redirect.png"),
                            }
                            node.style.fill = "#2B384E";   //colorSets[cid].mainStroke; 
                            node.style.stroke = "#2B384E";
                            graph.addItem('node',node );
                        }
                    })

                    data.edges.forEach((edge)=>{
                        // edge.label=null;
                        const rs = graph.find("edge",(oedge)=>{
                            return oedge.get('model').source==edge.source&& oedge.get('model').target==edge.target;
                        })
                        console.log(rs)
                        if(!rs){
                            const cid = clusterEdge.indexOf(edge.label);
                            edge.legendType=edge.label;
                            edge.style = {
                                stroke: colorSets[cid].mainStroke,
                                endArrow:{
                                    path: G6.Arrow.triangle(),
                                    fill:colorSets[cid].mainStroke,
                                },
                            };
                            edge.color = colorSets[cid].mainStroke;  //设置边的颜色
                            edge.labelCfg={
                                autoRotate: true,
                                style: {
                                    lineWidth: 4,
                                    fill: colorSets[cid].mainStroke, //colorSets[i].mainStroke, //'#1890ff',  //文字颜色
                                    fontSize: 12, //标签文字大小：原来14px
                                    background: {
                                        fill: "#2B384E",//colorSets[cid].mainFill, //标签背景颜色
                                        stroke: colorSets[cid].mainStroke,  //colorSets[cid].mainStroke 标签边框
                                        padding: [2, 2, 2, 2],
                                        radius: 2,
                                    },
                                },
                            };
                            edge.id = 'edge' + edge.id;
                            graph.addItem('edge',edge );
                            newEdgeCount+=1;
                        }
                    })
                    if(newNodeCount==0){
                        this.noMoreInfo()
                    }else{
                        this.haveMoreInfo(newNodeCount,newEdgeCount)
                    }
                })
            }
            //菜单 
            const contextMenu = new G6.Menu({
                shouldBegin(evt) {
                    if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) return true;
                    if (evt.item) return true;
                    return false;
                },
                getContent(evt) {
                    const { item } = evt;
                    let header;
                    if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) { //右键画布
                        return `<ul>
                        <li id='show'>显示全部隐藏节点</li>
                        <li id='collapseAll'>Collapse all Clusters</li>
                        </ul>`;
                    } 
                    else if (!item) return;
                    const itemType = item.getType();
                    const model = item.getModel();
                    if (itemType && model) {
                        if (itemType == 'node') { //右键节点
                            return `
                                <ul>
                                    <li id='expand'>展开一度关联节点</li>
                                    <li id='expand2'>展开二度关联节点</li>
                                    <li id='hideNeighbor'>折叠关联节点</li>
                                    <li id='hide'>隐藏节点</li>
                                </ul>`;
                        }
                    }
                },
                handleMenuClick: (target, item) => {
                    const model = item && item.getModel();
                    const liIdStrs = target.id.split('-');
                    let mixedGraphData;
                    switch (liIdStrs[0]) {
                    case 'hide':
                        graph.hideItem(item);
                        hiddenItemIds.push(model.id);
                        break;
                    case 'expand':
                        findNeighbors(graph,model)
                        break;
                    case 'expand2':
                        findNeighbors(graph,model,2)
                            break;
                    case 'collapse':
                        const aggregatedNode = aggregatedNodeMap[model.clusterId];
                        manipulatePosition = { x: aggregatedNode.x, y: aggregatedNode.y };
                        collapseArray.push(aggregatedNode);
                        for (let i = 0; i < expandArray.length; i++) {
                            if (expandArray[i].id === model.clusterId) {
                                expandArray.splice(i, 1);
                                break;
                            }
                        }
                        mixedGraphData = getMixedGraph(
                            clusteredData,
                            data,
                            nodeMap,
                            aggregatedNodeMap,
                            expandArray,
                            collapseArray,
                        );
                        break;
                    case 'collapseAll':
                        newAddArray.forEach(id=>{
                            graph.hideItem(id)
                        });
                        break;
                    case 'neighbor':
                        const expandNeighborSteps = parseInt(liIdStrs[1]);
                        mixedGraphData = getNeighborMixedGraph(
                            model,
                            expandNeighborSteps,
                            data,
                            clusteredData,
                            currentUnproccessedData,
                            nodeMap,
                            aggregatedNodeMap,
                            10,
                        );
                        break;
                    case 'hideNeighbor':
                        const node = graph.findById(model.id);
                        const neightborList = node.getNeighbors()
                        neightborList.forEach(element=>{
                            const id = element.getModel().id
                            graph.hideItem(id)
                            hiddenItemIds.push(id); //将邻居节点id加入隐藏数组
                        })
                        //隐藏节点本身
                        graph.hideItem(item);
                        hiddenItemIds.push(model.id);
                        break;
                    case 'show':
                        showItems(graph);
                        break;
                    default:
                        break;
                    }
                    if (mixedGraphData) {
                        cachePositions = cacheNodePositions(graph.getNodes());
                        currentUnproccessedData = mixedGraphData;
                        handleRefreshGraph(
                            graph,
                            currentUnproccessedData,
                            CANVAS_WIDTH,
                            CANVAS_HEIGHT,
                            largeGraphMode,
                            true,
                            false,
                        );
                    }
            },
                // offsetX and offsetY include the padding of the parent container
                // 需要加上父级容器的 padding-left 16 与自身偏移量 10
                offsetX: 16 + 10,
                // 需要加上父级容器的 padding-top 24 、画布兄弟元素高度、与自身偏移量 10
                offsetY: 0,
                // the types of items that allow the menu show up
                // 在哪些类型的元素上响应
                itemTypes: ['node', 'edge', 'canvas'],
            });
            //工具栏
            const toolbar = new G6.ToolBar({
                position: { x: 10, y: 10 },
            });

            const graph = new G6.Graph({
                container: containerId,
                width,   //: 800,
                height,//: 500,
                // fitView:true, 别开最好
                //TODO:注意 fitCenter和layout中的center只选择一个
                // fitCenter: true,
                modes: {
                    default: ['drag-canvas', 'zoom-canvas'],
                },
                
                layout: {
                    type: 'force',
                    linkDistance: linkDistance, //边的长度 180
                    preventOverlap: true,
                    nodeStrength: -170,  //节点的引力，负数代表斥力
                    center: [width / 2, height / 2],     // 可选，默认为图的中心
                    onTick, //TODO:constrainbox
                },
                defaultNode: {
                    size: nodeSize,
                    type: 'circle',
                    style: {
                        lineWidth: 2,
                        fill:"2B384E",
                        stroke:"2B384E"
                    },
                    labelCfg: {
                        position: 'bottom',
                        position: 'bottom',
                        style: {
                            fill: '#fff',
                            stroke: '#191b1c',
                        },
                    },
                    icon: {
                        show: true,
                        width: nodeIconSize,
                        height: nodeIconSize
                        // img: 'https://gw.alipayobjects.com/zos/basement_prod/012bcf4f-423b-4922-8c24-32a89f8c41ce.svg',
                        /* icon's size, 20 * 20 by default: */
                        //   width: 40,
                        //   height: 40
                    },
                },
                defaultEdge: {
                    style:{  //TODO:可以修改箭头的样式  https://g6.antv.antgroup.com/manual/middle/elements/edges/arrow
                        endArrow:true,
                        realEdgeOpacity,
                        strokeOpacity: realEdgeOpacity,
                        lineWidth:2,
                    },
                    
                },
                nodeStateStyles: {
                    activeByLegend: {
                        lineWidth: 10,
                        strokeOpacity: 0.5
                    },
                    inactiveByLegend: {
                        
                    },
                    active: {
                        lineWidth: 10,
                        strokeOpacity: 0.5
                    },
                    inactive:{ //必须设置这个，否则node样式会变化
                        fill:"#2B384E",
                        stroke:"#2B384E"
                    }
                },
                edgeStateStyles: {
                    activeByLegend: {
                        lineWidth: 3
                    },
                    inactiveByLegend: {
                        opacity: 0.5
                    }
                },
                animate: true,
                // 设置为true，启用 redo & undo 栈功能
                enabledStack: true,
                plugins: [contextMenu],
            });
            this.graphCanvas = graph;

            
            graph.data({
                nodes: data.nodes,
                edges: data.edges.map(function (edge, i) {
                    edge.id = 'edge' + edge.id;
                    return Object.assign({}, edge);
                }),
            });
            graph.render();
            graph.on('node:dragstart', function (e) {
                graph.layout();
                    refreshDragedNodePosition(e);
            });
            graph.on('node:drag', function (e) {
                const forceLayout = graph.get('layoutController').layoutMethods[0];
                forceLayout.execute();
                refreshDragedNodePosition(e);
            });
            graph.on('node:dragend', function (e) {
                e.item.get('model').fx = null;
                e.item.get('model').fy = null;
            });
            graph.on('afteradditem',function (e) {
                console.log("after add回调函数")
                graph.layout();
                refreshDragedNodePosition(e);
            });

            graph.on('node:mouseenter', (evt) => {
                const { item } = evt;
                graph.setItemState(item, 'active', true);
                // const neighbors = graph.getNeighbors(item);
                // const edges = graph.getEdges(); // 获取图中的所有边
                // neighbors.forEach((neighbor) => {
                //     const edge = edges.filter(edge => edge.getSource() === node || edge.getTarget() === neighbor); // 筛选出与该节点相关的边   
                //     edge.labelCfg={
                //         autoRotate: true,
                //         style: {
                //             lineWidth: 4,
                //             fill: "#fff", // colorSets[cid].mainStroke, //'#1890ff',  //文字颜色
                //             fontSize: 12, //标签文字大小：原来14px
                //         },
                //     };
                // });
                
            });

            graph.on('node:mouseleave', (evt) => {
                const { item } = evt;
                graph.setItemState(item, 'active', false);
            });

            if (typeof window !== 'undefined')
            window.onresize = () => {
                if (!graph || graph.get('destroyed')) return;
                if (!container || !container.scrollWidth || !container.scrollHeight) return;
                graph.changeSize(container.scrollWidth, container.scrollHeight);
            };

            function refreshDragedNodePosition(e) {
            const model = e.item.get('model');
            model.fx = e.x;
            model.fy = e.y;
            }
        }, 
        showSimilar(ifshow){
            const edges = this.graphCanvas.getEdges();
            edges.forEach(edge => {
                var edge = edge.getModel();
                if(ifshow){
                    console.log(edge)
                    edge.label = edge.properties.similarity.toFixed(2);
                    edge.labelCfg={
                        autoRotate: true,
                        style: {
                            lineWidth: 4,
                            fill: "#fff", // colorSets[cid].mainStroke, //'#1890ff',  //文字颜色
                            fontSize: 10, //标签文字大小：原来14px
                        },
                    };
                }else{
                    console.log("关闭标签")
                    edge.label = '';
                }
                const item = this.graphCanvas.findById(edge.id);
                item.update(edge);
            })
        },
        showSitesName(ifshow){
            const nodes = this.graphCanvas.getNodes();
            nodes.forEach(node => {
                var node = node.getModel();
                if(ifshow){
                    console.log(node)
                    node.label = node.properties.name;
                    node.labelCfg={
                        position: 'bottom',
                        position: 'bottom',
                        style: {
                            fill: '#fff',
                            stroke: '#191b1c',
                        },
                    };
                    // 更新节点标签
                    const item = this.graphCanvas.findById(node.id);
                    this.graphCanvas.updateItem(item,node);
                    // this.graphCanvas.refresh()
                }else{
                    node.label = '';
                    const item = this.graphCanvas.findById(node.id);
                    this.graphCanvas.updateItem(item,node);
                }
            })
            // this.graphCanvas.refresh()
        },
        filterSimilarity(startVal,endVal){
            const edges = this.graphCanvas.getEdges();
            var showSet = new Set();
            var hideSet = new Set();
            edges.forEach(edge=>{
                var edge = edge.getModel();
                const source = this.graphCanvas.findById(edge.source);
                const target = this.graphCanvas.findById(edge.target);
                const similarity = edge.properties.similarity;

                if (similarity >= startVal && similarity <= endVal) {
                    console.log(edge,"显示",source,target)
                    showSet.add(source);
                    showSet.add(target);
                    // this.graphCanvas.showItem(source);
                    // this.graphCanvas.showItem(target);
                } else {
                    // console.log(edge,"需要被隐藏")
                    hideSet.add(source)
                    hideSet.add(target)
                    // this.graphCanvas.hideItem(source);
                    // this.graphCanvas.hideItem(target);
                    // this.graphCanvas.refresh();
                }
                //如果某个节点在showSet中，则从hideSet中移出此元素
            })
            console.log('隐藏组',hideSet)
            console.log('显示组',showSet)
            showSet.forEach(function(val) {
                if (hideSet.has(val)) {
                    hideSet.delete(val);
                }
            });
            hideSet.forEach(node=>{
                this.graphCanvas.hideItem(node);
            })
            showSet.forEach(node=>{
                this.graphCanvas.showItem(node);
            })
            // this.graphCanvas.refresh();
        },
        exportGraph() {
            // const dataURL = this.graphCanvas.toDataURL();
            // const link = document.createElement('a');
            // link.href = dataURL;
            // link.download = 'graph.png';
            // link.click();
            this.graphCanvas.downloadFullImage('similar-graph', 'image/png', {
                backgroundColor: '#ddd',
                padding: [30, 15, 15, 15],
            });
        },
        exportCsv(){
             // 获取G6图谱数据
            const data = this.graphCanvas.getEdges();
            let csvContent = '';
            csvContent += '起始网站,目标网站,相似度,\n'; // 表头
            data.forEach(edge=>{
                var edge = edge.getModel();
                const source = this.graphCanvas.findById(edge.source).getModel();
                const target = this.graphCanvas.findById(edge.target).getModel();
                csvContent += `${source.properties.name},${target.properties.name},${edge.properties.similarity}\n`; // 表格内容
            })

            // const data = this.graphCanvas.getNodes();
            // let csvContent = '';
            // csvContent += 'id,label,name,\n'; // 表头
            // data.forEach((node) => {
            //     var node = node.getModel();
            //     csvContent += `${node.id},${node.legendType},${node.properties.name}\n`; // 表格内容
            // });
            // 创建Blob对象并下载文件
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
            saveAs(blob, '网站相似度.csv');
        },
        isTrueUrl(value){
            let reg = /(https?|ftp|file):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/
            if (!reg.test(value)) {
                this.$message({
                    message: '请输入正确的网站链接！',
                    type: 'warning'
                });
                return false;
            }
            return true;
        },
        searchWebsite(){
            const legal = this.isTrueUrl(this.input);
            if(!legal){
                return
            }

            this.axios({
                url:"api/graph/similar/site?url="+this.input,
                method:'get'
            }).then(res=>{
                this.searchData=res.data;
                // 更新数据并重新渲染画布
                const subjectColors = [
                    '#5F95FF', // blue
                    '#61DDAA',
                    // '#65789B',
                    '#F6BD16',
                    '#9661BC', //purple
                    '#78D3F8',
                    // '#9661BC',
                    '#F6903D',
                    '#008685',
                    '#F08BB4',
                ];
                const backColor = '#2B384E';//
                const theme = 'dark';
                const disableColor = '#777';
                const colorSets = G6.Util.getColorSetsBySubjectColors(
                    subjectColors,
                    backColor,
                    theme,
                    disableColor,
                );
                //给新节点上色
                const clusterNode = ["Website","Company","Person","Ip","Redirect"];
                const clusterEdge = ["SIMILAR_TO","BELONGS_TO","DOWNLOAD_FROM","HAS_IP","HAS_COMPANY",];
                this.searchData.nodes.forEach(function (node) {
                    const cid = clusterNode.indexOf(node.label);
                    node.size=25;
                    node.legendType=node.label;
                    node.label=node.properties.name;
                    if (!node.style) {
                        node.style = {};
                    }
                    node.icon = {
                        show:true,
                        img:require("@/assets/nodes/"+node.legendType+".png"),
                        width: 25,
                        height: 25
                    };
                    node.style.fill = "#2B384E"; //subjectColors
                    node.style.stroke = "#2B384E"; //strokes[cid % strokes.length];
                });
                this.searchData.edges.forEach(edge => {
                    const cid = clusterEdge.indexOf(edge.label);
                    edge.legendType=edge.label;
                    // edge.label=null;
                    edge.label=edge.properties.similarity.toFixed(2);
                    edge.style = {
                        stroke: colorSets[cid].mainStroke,
                        endArrow:{
                            path: G6.Arrow.triangle(),
                            fill:colorSets[cid].mainStroke,
                        },
                    };
                    edge.color = colorSets[cid].mainStroke;  //设置边的颜色
                    edge.labelCfg={
                        autoRotate: true,
                        style: {
                            lineWidth: 4,
                            fill: "#fff", // colorSets[cid].mainStroke, //'#1890ff',  //文字颜色
                            fontSize: 10, //标签文字大小：原来14px
                        },
                    };
                })
                this.graphCanvas.changeData(this.searchData);
            })
        },
        add(){
            //add new data to graphData and render
            this.graphData.nodes.push({
                id: this.graphData.nodes.length,
                label: 'new node',
                x: Math.random() * 800,
                y: Math.random() * 800,
            });
            this.graphData.edges.push({
                source: parseInt(Math.random() * this.graphData.nodes.length),
                target: parseInt(Math.random() * this.graphData.nodes.length),
            });
            this.graphCanvas.changeData(this.graphData);
        }

    },
    mounted(){
        this.showSomeSimilar()
    }
}
</script>

<style scoped>
    .el-row{
        margin-bottom: 10px;
    }

    .similar-graph{
        width:1000px;
        height:600px;
    }
    .el-slider{
        width: 250px;
    }
    /**.search-wrapper {
        position: absolute;
        transform: translate(-50%, -50%);
        top:50%;
        left:50%;
    }**/
  
    .search-wrapper .input-holder {    
        height: 50px;
        width:70px;
        overflow: hidden;
        background: rgba(255,255,255,0);
        border-radius:6px;
        position: relative;
    }
    .search-wrapper .input-holder {
        width:450px;
        border-radius: 50px;
        background: rgba(0,0,0,0.5);
    }    

    .search-wrapper .input-holder .search-input {
        width:100%;
        height: 30px;
        padding:0px 70px 0 20px;
        opacity: 0;
        position: absolute;
        top:0px;
        left:0px;
        background: transparent;
        box-sizing: border-box;
        border:none;
        outline:none;
        font-family:"Open Sans", Arial, Verdana;
        font-size: 16px;
        font-weight: 400;
        line-height: 20px;
        color:#FFF;
        transform: translate(0, 60px);
        transition: all .3s cubic-bezier(0.000, 0.105, 0.035, 1.570);
        transition-delay: 0.3s;
    }
    .search-wrapper .input-holder .search-input {
        opacity: 1;
        transform: translate(0, 10px);
    }
    .search-wrapper .input-holder .search-icon {
        width:70px;
        height:50px;
        border:none;
        border-radius:6px;
        background: #1f1e21;
        padding:0px;
        outline:none;
        position: relative;
        z-index: 2;
        float:right;
        cursor: pointer;
        transition: all 0.3s ease-in-out;
    }
    .search-wrapper.input-holder .search-icon {
        width: 50px;
        height:50px;
        margin: 10px;
        border-radius: 30px;
    }
    .search-wrapper .input-holder .search-icon span {
        width:22px;
        height:22px;
        display: inline-block;
        vertical-align: middle;
        position:relative;
        transform: rotate(45deg);
        transition: all .4s cubic-bezier(0.650, -0.600, 0.240, 1.650);
    }
    .search-wrapper.input-holder .search-icon span {
        transform: rotate(-45deg);
    }
    .search-wrapper .input-holder .search-icon span::before, 
    .search-wrapper .input-holder .search-icon span::after {
        position: absolute; 
        content:'';
    }
    .search-wrapper .input-holder .search-icon span::before {
        width: 4px;
        height: 11px;
        left: 9px;
        top: 18px;
        border-radius: 2px;
        background: #FE5F55;
    }
    .search-wrapper .input-holder .search-icon span::after {
        width: 14px;
        height: 14px;
        left: 0px;
        top: 0px;
        border-radius: 16px;
        border: 4px solid #FE5F55;
    }
    .search-wrapper .close {
        position: absolute;
        z-index: 1;
        top:24px;
        right:20px;
        width:25px;
        height:25px;
        cursor: pointer;
        transform: rotate(-180deg);
        transition: all .3s cubic-bezier(0.285, -0.450, 0.935, 0.110);
        transition-delay: 0.2s;
    }
    .search-wrapper .close {
        right:-50px;
        transform: rotate(45deg);
        transition: all .6s cubic-bezier(0.000, 0.105, 0.035, 1.570);
        transition-delay: 0.5s;
    }
    .search-wrapper .close::before, .search-wrapper .close::after {
        position:absolute;
        content:'';
        background: #FE5F55;
        border-radius: 2px;
    }
    .search-wrapper .close::before {
        width: 5px;
        height: 25px;
        left: 10px;
        top: 0px;
    }
    .search-wrapper .close::after {
        width: 25px;
        height: 5px;
        left: 0px;
        top: 10px;
    }    
</style>